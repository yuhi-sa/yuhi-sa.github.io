<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on tomato blog</title>
    <link>https://yuhi-sa.github.io/posts/</link>
    <description>Recent content in Posts on tomato blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Sat, 16 Mar 2024 09:00:23 +0900</lastBuildDate>
    <atom:link href="https://yuhi-sa.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>直近やること</title>
      <link>https://yuhi-sa.github.io/posts/20240316_todo/1/</link>
      <pubDate>Sat, 16 Mar 2024 09:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20240316_todo/1/</guid>
      <description>読む 実践Next.js —— App Routerで進化するWebアプリ開発 見る ドメイン駆動設計 Go動画 作る 副業のバックエンド 本業の自分用アプリ </description>
    </item>
    <item>
      <title>2024年目標</title>
      <link>https://yuhi-sa.github.io/posts/todo/</link>
      <pubDate>Thu, 04 Jan 2024 10:10:00 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/todo/</guid>
      <description>前提 人生のゴール 定年までエンジニアとして働く。 安心安全な老後の住美をする。 20代のゴール 婚活市場における普通の人。 都心の2LDKマンションに住む。 エンジニアとしてどこにでも転職できる状態。 20代のゴール達成に必要なこと 金 年収向上。 副業収入。 支出削減。 清潔感 痩せる。 筋肉をつける。 規則正しい生活をする。 知性 専門性。 教養。 性格 感じの良さ。 2024年にすべきこと 仕事 (金：年収向上,知性：専門性)本業： ゴール１：質の向上。 やること：タスク内容を解釈の余地が生まれないレベルで詳述する。 やること：完璧に仕組みを説明できる状態でPRを出す。 ゴール２：設計レベルの提案実施 やること：設計タスクがあれば、最低一つ自分の案を提案する。 (金：年収向上,知性：専門性)副業： ゴール1：副業収入の安定。 やること：~~平日5時間and土日5時間の作業時間を確保する。~~週5時間確保する。 やること：青色確定申告をする。 私生活 (清潔感)痩せる。筋肉をつける。 ゴール１：体重55kg。 やること：週１でパーソナルジム行く。 やること：毎食食事を記録する。 やること：毎日体重計に乗る。 ゴール２：禁酒。 やること：平日の夜は、家で酒を飲まない ゴール３：健康な食事。 やること：添加物を極力取らない。 やること：炭水化物を控える。 (知性)知識を増やす。 ゴール１：本を読む。 やること：朝1ページだけでも本を読む。 ゴール２：TOEIC750点 やること：スタディサプリ毎日1セクション＋単語 ゴール３：韓国語5級 やること：Duolingo毎日1セクション ゴール4：技術力UP。 やること：帰りの電車でUdemyを見る。 やること：予定がない週はAtcoderに参加する。 やること：TryHackMeを2日に1回実施。 (金)節約する。 ゴール１：moneyforwardの予算を厳守する。 やること：特別な支出をしない。 やること：一人で外食をしない。 ゴール２：将来のお金計画を立てる。 やること：ライフプランシミュレーションをする。 (性格)感じの良さ。 ゴール１：ポジティブな人間になる。 やること：ネガティブな言葉を使わない。 </description>
    </item>
    <item>
      <title>読む予定の本</title>
      <link>https://yuhi-sa.github.io/posts/read/</link>
      <pubDate>Thu, 04 Jan 2024 10:10:00 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/read/</guid>
      <description> 「日経平均10万円」時代が来る！ 暴政 ドメイン駆動設計入門 行動経済学が最強の学問である Think bigger １３歳からの地政学 </description>
    </item>
    <item>
      <title>2023年の振り返り</title>
      <link>https://yuhi-sa.github.io/posts/20231231_hurikaeri/1/</link>
      <pubDate>Sun, 31 Dec 2023 10:00:00 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20231231_hurikaeri/1/</guid>
      <description>仕事 チームが変わった 上司が変わった 会社が合併した Weworkに行くようになった(最近やめた) オフィスに行くようになった 副業を2つ始めた 個人事業主の申請した 勉強 オンラインサロンに入って開発をした(退会した) 情報処理安全確保士に合格した TOEICが645点になった 韓国語を勉強し始めた 図書館に通うようになった 生活 脱毛完了した 歯の矯正を初めて完了した パーソナルジムに行ってダイエットした(68-&amp;gt;59) フロアクリーニングした 一ヶ月間禁酒した FP相談して人生計画立てた その他 髪の毛をピンクにした ルンバとお別れした あさみみにハマった 2024年の目標 https://yuhi-sa.github.io/posts/todo/ </description>
    </item>
    <item>
      <title>TypescriptとReactでHugoのテーマを自作する</title>
      <link>https://yuhi-sa.github.io/posts/20231218_hugo/1/</link>
      <pubDate>Mon, 18 Dec 2023 09:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20231218_hugo/1/</guid>
      <description>TypescriptとReactを導入してHugoのthemeを作成してみたのでメモを残す。 hugo自体の設定をしたメモは、markdownで記事を作成して無料ブログをつくる[Github Pages+Hugo]に記載。&#xA;Hugoのテーマを初期化 hugo new themeコマンドでテーマの雛形を作ることができる。 以下は、具体的な例としてtomatohugoという名前のテーマを初期化するコマンド。&#xA;hugo new theme tomatohugo このコマンドを実行すると、tomatohugoディレクトリが作成され、その中に様々なファイルやディレクトリが生成される。&#xA;➜ tomatohugo git:(main) tree . . ├── LICENSE ├── README.md ├── archetypes │ └── default.md ├── assets │ ├── css │ │ └── main.css │ └── js │ └── main.js ├── content │ ├── _index.md │ └── posts │ ├── _index.md │ ├── post-1.md │ ├── post-2.md │ └── post-3 │ ├── bryce-canyon.jpg │ └── index.md ├── data ├── hugo.</description>
    </item>
    <item>
      <title>エクセルファイルをCSVファイルに変換するshellスクリプト</title>
      <link>https://yuhi-sa.github.io/posts/20231213_shell/1/</link>
      <pubDate>Tue, 12 Dec 2023 09:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20231213_shell/1/</guid>
      <description># 変換対象のExcelファイルが存在するディレクトリ input_dir=~/Desktop # 変換後のCSVファイルを保存するディレクトリ output_dir=~/Desktop/csv_output # 出力ディレクトリが存在しない場合は作成する mkdir -p &amp;#34;$output_dir&amp;#34; # ExcelファイルをCSVに変換する関数 convert_excel_to_csv() { input_file=&amp;#34;$1&amp;#34; output_file=&amp;#34;$output_dir/$(basename &amp;#34;${input_file%.*}&amp;#34;).csv&amp;#34; python3 -m xlsx2csv &amp;#34;$input_file&amp;#34; &amp;#34;$output_file&amp;#34; echo &amp;#34;変換完了: $output_file&amp;#34; } # ExcelファイルをCSVに変換するループ for excel_file in &amp;#34;$input_dir&amp;#34;/*.xlsx; do convert_excel_to_csv &amp;#34;$excel_file&amp;#34; done </description>
    </item>
    <item>
      <title>Gitのコミットメッセージを効果的に統一するためにcommitizenを利用する</title>
      <link>https://yuhi-sa.github.io/posts/20231208_cz/1/</link>
      <pubDate>Fri, 08 Dec 2023 09:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20231208_cz/1/</guid>
      <description>commitizenとは commitizenは、Gitのコミットメッセージを効果的に統一するためのツールで、対話的なプロンプトを提供してコミットメッセージを作成できる。これにより、一貫性のあるメッセージを作成しやすくなる。&#xA;導入 commitizenのインストール 最初に、以下のコマンドを使用してcommitizenをグローバルにインストールする。&#xA;➜ npm install -g commitizen これにより、commitizenがコマンドラインから利用可能になる。&#xA;cz-conventional-changelogのインストール commitizenを使用する際、どのような形式でコミットメッセージを記述するかを定義するツールが必要となる。 今回は、cz-conventional-changelogを使用する。cz-conventional-changelogは、Conventional Commitsと呼ばれるフォーマットに従ったコミットメッセージの記載が可能となる。&#xA;以下のコマンドを実行して、これをインストールする。&#xA;➜ npm install -g cz-conventional-changelog 設定ファイルに追加する。&#xA;➜ vim .czrc { &amp;#34;path&amp;#34;: &amp;#34;cz-conventional-changelog&amp;#34; } これにより、cz-conventional-changelogが利用可能になる。&#xA;使用方法 通常のgit commitコマンドではなく、 git czコマンドを使用してコミットメッセージを作成する。このコマンドを実行すると、対話型のプロンプトが表示され、コミットメッセージの各部分を選択して入力することができる。&#xA;➜ git:(main) touch test.md ➜ git:(main) ✗ git add test.md ➜ git:(main) ✗ git cz cz-cli@4.3.0, cz-conventional-changelog@3.3.0 ? Select the type of change that you&amp;#39;re committing: (Use arrow keys) ❯ feat: A new feature fix: A bug fix docs: Documentation only changes style: Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc) refactor: A code change that neither fixes a bug nor adds a feature perf: A code change that improves performance </description>
    </item>
    <item>
      <title>Gitフックを使ってローカル環境で、mainブランチへのpushを禁止する</title>
      <link>https://yuhi-sa.github.io/posts/20231204_git/1/</link>
      <pubDate>Mon, 04 Dec 2023 09:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20231204_git/1/</guid>
      <description>Gitフックは、特定のGitイベントが発生したときに実行されるスクリプトである。 これを使用して、masterブランチへのpushを制限できる。&#xA;.git/hooksディレクトリにスクリプトを作成する。&#xA;cd .git/hooks vim pre-push 以下の内容を追加する。&#xA;#!/bin/bash current_branch=$(git symbolic-ref HEAD --short) if [ &amp;#34;$current_branch&amp;#34; = &amp;#34;main&amp;#34; ]; then echo &amp;#34;Error: Direct push to main branch is not allowed.&amp;#34; exit 1 fi exit 0 スクリプトに実行権限を与える。&#xA;chmod +x pre-push これで、masterブランチへの直接のpushが拒否されるようになる。</description>
    </item>
    <item>
      <title>App RouterとPages Routerでprom-clientの値を共有できない</title>
      <link>https://yuhi-sa.github.io/posts/20231124_t3/1/</link>
      <pubDate>Fri, 24 Nov 2023 09:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20231124_t3/1/</guid>
      <description>t3-stackでログのメトリクス化のために、prom-clientのCounterをLoggerクラスで共有することを検討した。 しかし、App RouterとPages Routerで共有することができなかった。 具体的にはglobalのregisterにCounterを登録しようとするとPages Routerではビルドエラーになる。&#xA;import { Counter } from &amp;#39;prom-client&amp;#39;; class Logger { private static instance: Logger; private errorCounter: Counter&amp;lt;string&amp;gt;; private warnCounter: Counter&amp;lt;string&amp;gt;; private constructor() { this.errorCounter = new Counter({ name: &amp;#39;errors_total&amp;#39;, }); this.warnCounter = new Counter({ name: &amp;#39;warnings_total&amp;#39;, }); } public static getInstance(): Logger { if (!Logger.instance) { Logger.instance = new Logger(); } return Logger.instance; } } 回避方法としてregisterをLoggerクラスに持たせることができるが、App RouterとPages Routerで別々のinstanceを使用することとなる。そのため、やはりメトリクスを共有できない。&#xA;import { Counter, register } from &amp;#39;prom-client&amp;#39;; class Logger { private static instance: Logger; private errorCounter: Counter&amp;lt;string&amp;gt;; private warnCounter: Counter&amp;lt;string&amp;gt;; private registerInstance: typeof register; private constructor() { this.</description>
    </item>
    <item>
      <title>mtailを用いてPrometheus形式のメトリクスを公開する</title>
      <link>https://yuhi-sa.github.io/posts/20231124_mtail/1/</link>
      <pubDate>Fri, 24 Nov 2023 09:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20231124_mtail/1/</guid>
      <description>概要 mtail(https://github.com/google/mtail )は、Googleが提供するログパースツールで、ログファイルから指定したパターンに一致する行を抽出し、それに基づいてメトリクスを生成して/metricsエンドポイントにPrometheus形式で公開することができるソフトウェアである。&#xA;mtailの使い方 mtailを利用するには、設定ファイルを定義し、ログファイルのパスとパターンを指定する必要がある。&#xA;設定ファイル (例: sample.mtail) # メトリクスの初期化 counter errors_total # ログファイル内のマッチングするパターン /error/ { errors_total++ } counter errors_totalは、Prometheusで使用するメトリクスを定義している。counterはカウンタータイプのメトリクスで、ログファイル内で特定のエラーパターンが一致するたびに値が増加する。&#xA;/error/ {...}は、ログファイル内のエラーパターンを指定している。この例では、ログの各行が/error/という文字列を含む場合に、その行が一致すると見なされ、errors_totalカウンターが増加する。&#xA;Dockerで起動 FROM centos7:latest RUN yum install -y wget &amp;amp;&amp;amp; yum clean all WORKDIR /tmp RUN wget -O mtail.tar.gz https://github.com/google/mtail/releases/download/v3.0.0-rc52/mtail_3.0.0-rc52_linux_amd64.tar.gz &amp;amp;&amp;amp; \ tar xzvf mtail.tar.gz &amp;amp;&amp;amp; \ chmod +x mtail CMD [&amp;#34;/tmp/mtail&amp;#34;, &amp;#34;-progs&amp;#34;, &amp;#34;/path/to/sample.mtail&amp;#34;, &amp;#34;-logs&amp;#34;, &amp;#34;/path/to/logfile&amp;#34;] EXPOSE 3903 -progs /path/to/sample.mtail: mtailが使用する設定ファイル（sample.mtail）のパスを指定している。 -logs /path/to/logfile: mtailが監視するログファイルのパスを指定している。mtailはこのログファイルを監視し、設定ファイルに定義されたパターンに一致する行を検出して対応するメトリクスを生成する。 </description>
    </item>
    <item>
      <title>DH鍵交換（Diffie-Hellman鍵交換）をpythonで確認</title>
      <link>https://yuhi-sa.github.io/posts/20230907_dh/1/</link>
      <pubDate>Wed, 06 Sep 2023 09:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20230907_dh/1/</guid>
      <description>概要 DH鍵交換は、1976年にWhitfield DiffieとMartin Hellmanによって発表されたプロトコルである。このプロトコルでは、通信を行う2者がそれぞれ公開鍵と秘密鍵を生成し、公開鍵だけを相手に送信する。そして、自分の秘密鍵と受信した相手の公開鍵を使用して共通鍵を生成する。&#xA;このプロトコルを用いることにより、共通鍵を使い捨てすることができ、前方秘匿性を保持するために重要である。前方秘匿性とは、過去の通信から推測されることなく、将来の通信も安全に行えること。&#xA;アルゴリズム import random # 共通のパラメータ g = 23 # 生成元 n = 5 # 素数 # アリスとボブがそれぞれ秘密の鍵を生成 p = 5 # 秘密の鍵のビット長 a = random.randint(1, (1 &amp;lt;&amp;lt; p)) # アリスの秘密の鍵 b = random.randint(1, (1 &amp;lt;&amp;lt; p)) # ボブの秘密の鍵 # アリスとボブが公開鍵を計算 A = (g ** a) % n B = (g ** b) % n # アリスとボブが共通の秘密鍵を計算 sA = (B ** a) % n sB = (A ** b) % n # 共通の秘密鍵を表示 print(&amp;#34;共通の秘密鍵 sA:&amp;#34;, sA) print(&amp;#34;共通の秘密鍵 sB:&amp;#34;, sB) 公開鍵Aを盗聴できたとして攻撃者がaを計算しようとすると、総当たりにはo(2^p)の計算量が必要。</description>
    </item>
    <item>
      <title>DS201の実施_NodeSync</title>
      <link>https://yuhi-sa.github.io/posts/20230516_dse_cassandra/15/</link>
      <pubDate>Thu, 29 Jun 2023 09:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20230516_dse_cassandra/15/</guid>
      <description>DS201: Foundations of Apache Cassandra™ and DataStax Enterpriseの学習記録。&#xA;NodeSyncは、データの整合性を保ちつつオーバーヘッドを最小限に抑える機能。&#xA;NodeSyncは、以下の特徴を持つ：&#xA;すべてのレプリカ間でデータの同期を継続的に検証する。 常に実行されますが、クラスターのパフォーマンスにわずかな影響しか与えない。 完全に自動化されており、手動介入は必要ない。 アンチエントロピー・リペアの代替として機能する。 NodeSyncサービスは、デフォルトで各ノードで実行される。NodeSyncはテーブルごとに有効にすることができ、有効にされたテーブルのローカルデータ範囲を連続的に検証し、不整合が見つかった場合はリペアを実行する。データ範囲は小さなセグメントに分割され、優先度付けされる。&#xA;セグメントは、テーブルの小さなローカルトークン範囲である。NodeSyncはセグメントを選択し、データ全体を読み取り、不整合をチェックし、必要に応じてリペアする。セグメントの検証状態は、system_distributed.nodesync_statusテーブルに保存される。&#xA;セグメントの検証状態には、successful（正常終了）、full_in_sync（完全に同期済み）、full_repaired（完全にリペア済み）、unsuccessful（失敗）、partial_in_sync（一部の同期済み）、partial_repaired（一部がリペア済み）、uncompleted（未完了）、failed（エラー）などのステータスがある。</description>
    </item>
    <item>
      <title>DS201の実施_WritePathとReadPath</title>
      <link>https://yuhi-sa.github.io/posts/20230516_dse_cassandra/16/</link>
      <pubDate>Thu, 29 Jun 2023 09:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20230516_dse_cassandra/16/</guid>
      <description>DS201: Foundations of Apache Cassandra™ and DataStax Enterpriseの学習&#xA;WritePath CassandraのWritePath（データの書き込み操作が行われるプロセス）は以下の通りである。&#xA;Cassandraでは、データの変更はまずコミットログ（commit log）に書き込まれる。コミットログはHDDまたはSSD上に配置され、データの永続性を確保する。コミットログはデータベースの更新操作を追跡するためのログファイルとなる。Cassandraは書き込みリクエストを受け取るたびに、対応するデータの変更をコミットログに書き込みを実行する。 データがコミットログに書き込まれた後、CassandraはRAM（ランダムアクセスメモリ）内にメモリテーブル（memtable）を作成する。メモリテーブルはデータの追加や更新を高速に処理するために使用する。メモリテーブルはデータの一時的な格納場所であり、最新のデータのバージョンを保持する。データはRAM内に存在するため、ディスクアクセスに比べて高速な読み書きが可能である。ただし、メモリテーブルはシステムのメモリ容量によって制限されるため、一定の容量を超えるとディスクに書き出される。 メモリテーブル内のデータが一定の容量を超えると、Cassandraはメモリテーブルの内容をSSTable（Sorted String Table）と呼ばれるディスク上の構造に書き出します。SSTableはデータをソートされた状態で保存し、効率的な読み取り操作を可能としている。SSTableはディスク上の永続的なデータストレージである。 ReadPath CassandraのReadPath（データの読み取り操作が行われるプロセス）は以下の通りです。&#xA;データの読み取り操作が発生すると、Cassandraはまずメモリ内のキャッシュであるブルームフィルタ（Bloom Filter）を検索する。ブルームフィルタは、ディスク上のデータを検索する前にメモリ内で高速なフィルタリングを行うことで、ディスクアクセスを最小限に抑える。ブルームフィルタはデータの存在を確認するために使用され、データが存在しない場合はディスクアクセスを行わずに読み取り操作を終了する。 ブルームフィルタでデータの存在が確認された場合、Cassandraはデータを検索するためにディスク上のSSTableを使用する。複数のSSTableにまたがるデータを取得する場合、Cassandraはマージソート（Merge Sort）アルゴリズムを使用して複数のSSTableからデータを統合する。 データがディスクから読み込まれた後、Cassandraはキャッシュ（メモリ内のデータ）にデータをロードする。これにより、次回以降の読み取りでのディスクアクセスを回避し、高速なメモリアクセスでデータを実現する。 </description>
    </item>
    <item>
      <title>DS201の実施_Consistency</title>
      <link>https://yuhi-sa.github.io/posts/20230516_dse_cassandra/12/</link>
      <pubDate>Sun, 25 Jun 2023 09:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20230516_dse_cassandra/12/</guid>
      <description>DS201: Foundations of Apache Cassandra™ and DataStax Enterpriseの学習記録。&#xA;Cassandraでは、RF数に応じてデータを複数のノードに分散して格納している。Consistencyレベルは、クライアントがデータの一貫性をどの程度要求するかを制御するために使用される。&#xA;ANY: 読み取りまたは書き込み操作は、少なくとも1つのレプリカに対して成功した場合に完了する。&#xA;ONE, TWO, THREE: ConsistencyレベルをONEに設定すると、読み取りまたは書き込み操作は、データのレプリカのうち少なくとも1つに対して成功した場合に完了する。TWOの場合は、2つのレプリカに対して、THREEの場合は3つのレプリカに対して成功する必要がある。&#xA;QUORUM 読み取りまたは書き込み操作は、データのレプリカの過半数に対して成功した場合に完了する。例えば、3つのレプリカがある場合、2つのレプリカに成功する必要がある。&#xA;LOCAL_ONE 読み取りまたは書き込み操作は、ローカルデータセンター内の任意のレプリカに対して成功した場合に完了する。&#xA;LOCAL_QUORUM 読み取りまたは書き込み操作は、ローカルデータセンター内のレプリカの過半数に対して成功した場合に完了する。&#xA;EACH_QUORUM 読み取りまたは書き込み操作は、各データセンター内のレプリカの過半数に対して成功した場合に完了する。&#xA;ALL 読み取りまたは書き込み操作は、データのすべてのレプリカに対して成功した場合に完了する。</description>
    </item>
    <item>
      <title>DS201の実施_Hinted handoff</title>
      <link>https://yuhi-sa.github.io/posts/20230516_dse_cassandra/13/</link>
      <pubDate>Sun, 25 Jun 2023 09:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20230516_dse_cassandra/13/</guid>
      <description>DS201: Foundations of Apache Cassandra™ and DataStax Enterpriseの学習記録。&#xA;Hinted Handoffは、Cassandraデータベースクラスター内のノード間でデータのレプリケーションを行う際に使用される機能。ノードの障害や一時的なダウンタイムが発生した場合でも、データの耐障害性と可用性を確保するために使用される。&#xA;ノードがダウンしている場合やネットワーク接続が一時的に切断されている場合、データの書き込みや読み取りが影響を受ける可能性がある。Hinted Handoffは、ダウンしているノードのデータを一時的に別のノードに保存しておく仕組みである。例えば、データを書き込もうとしたノードがダウンしている場合、Hinted Handoffはそのデータのヒント（ヒント情報）を別のノードに保存します。そして、ダウンしていたノードが復旧した際に、ヒント情報を使用してデータをそのノードに渡すr。&#xA;ただし、Hinted Handoffは一時的な解決策であり、ノードが長期間ダウンしている場合やデータのヒント情報が大量に蓄積される場合には、適切な対策を講じる必要がある。また、Hinted Handoffはデフォルトで有効になっているが、必要に応じて設定を変更することもできる。</description>
    </item>
    <item>
      <title>DS201の実施_Read Repair</title>
      <link>https://yuhi-sa.github.io/posts/20230516_dse_cassandra/14/</link>
      <pubDate>Sun, 25 Jun 2023 09:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20230516_dse_cassandra/14/</guid>
      <description>DS201: Foundations of Apache Cassandra™ and DataStax Enterpriseの学習記録。&#xA;Cassandraでは、データのレプリカが複数のノードに存在し、それらのレプリカ間でデータの整合性を維持する必要がある。Read Repairは、読み取り操作が行われる際に自動的に実行される。&#xA;クライアントがデータを読み取るとき、Cassandraはレプリカセット(同じデータを保持する複数のノードのグループ)からデータを収集する。各レプリカは自身のタイムスタンプを持っており、最新のタイムスタンプを持つデータがクライアントに返さる。レプリカ間でデータのタイムスタンプが異なる場合、CassandraはRead Repairを使用して古いデータを更新することでデータの整合性を回復させる。&#xA;read_repair_chanceにより、読み取り操作時に自動的にRead Repairを実行する確率を指定する。この値は0から1の範囲で設定され、0は実行しないことを意味し、1は必ず実行することを意味する。</description>
    </item>
    <item>
      <title>DS201の実施_Replication</title>
      <link>https://yuhi-sa.github.io/posts/20230516_dse_cassandra/11/</link>
      <pubDate>Sun, 25 Jun 2023 09:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20230516_dse_cassandra/11/</guid>
      <description>DS201: Foundations of Apache Cassandra™ and DataStax Enterpriseの学習記録。&#xA;Cassandraは、データの冗長性と可用性を確保するためにReplication（複製）を行う。 Replicationはデータを複数のノードに複製することで、障害が発生してもデータの喪失やサービスの停止を防ぐ。Replication Factor（RF）と呼ばれるパラメータを使用して、各データセットの複製数を指定することができる。RFの値はクラスタ全体または特定のキースペース（Keyspace）ごとに設定できる。</description>
    </item>
    <item>
      <title>DS201の実施_Snitches</title>
      <link>https://yuhi-sa.github.io/posts/20230516_dse_cassandra/10/</link>
      <pubDate>Sat, 24 Jun 2023 09:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20230516_dse_cassandra/10/</guid>
      <description>DS201: Foundations of Apache Cassandra™ and DataStax Enterpriseの学習記録。&#xA;snitchは、ノードの位置情報を管理し、データの配置とレプリケーションを制御するための機能。ネットワークトポロジーとデータセンター構成に基づいて、Cassandraクラスタ内のノードの物理的な配置を決定する。&#xA;snitchの主な役割は、データの一貫性と耐障害性を確保すること。データは複数のノードにレプリケートされるため、ノードの配置によってデータの可用性とパフォーマンスが大きく左右される。&#xA;以下のような種類が存在する。&#xA;SimpleSnitch RackInferringSnitch GossipingPropertyFileSnitch </description>
    </item>
    <item>
      <title>ios17 Developer Betaにアップグレードしたiphone13をios16に戻す</title>
      <link>https://yuhi-sa.github.io/posts/20230618_iphone/1/</link>
      <pubDate>Sun, 18 Jun 2023 09:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20230618_iphone/1/</guid>
      <description>ベータアップデートをオフにする 設定&amp;gt;一般&amp;gt;ソフトウェアアップデートからベータアップデートをオフにする。&#xA;リカバリーモードにする mac bookとケーブルで接続する。 iphoneの音量↑ボタンを押した後、音量↓ボタンを押す。 すぐに電源ボタンを長押しする。電源が切れappleのロゴが出るまで長押しする。 iphoneはこのような画面。 macはこのような画面となる。 macから復元 上記の画面になったら、mac上から復元を選択する。&#xA;これで、再インストールすることができる。&#xA;通常のiphoneの初期設定 工場出荷時の状態となるため、通常の初期設定をiphoneで実施する。 この時ios17時点でのバックアップから復元することはできないため、1から設定をし直す必要がある。</description>
    </item>
    <item>
      <title>DS201の実施_Gossip</title>
      <link>https://yuhi-sa.github.io/posts/20230516_dse_cassandra/9/</link>
      <pubDate>Sat, 10 Jun 2023 09:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20230516_dse_cassandra/9/</guid>
      <description>DS201: Foundations of Apache Cassandra™ and DataStax Enterpriseの学習記録。&#xA;Cassandraのノード間の通信とデータの同期は、Gossipプロトコルに基づいて行われる。&#xA;Gossipは、ネットワーク内のノード間で情報を分散させるためのプロトコル。ノードは定期的にお互いに通信し、各ノードが保持する情報を交換する。この情報には、ノードの状態やトポロジー、データの位置情報などが含まれる。&#xA;具体的な動作手順は以下の通り。&#xA;各ノードは、互いに定期的に「ゴシップ（情報交換）」メッセージを送信。 ノードは、受信したメッセージに含まれる情報を自身の状態と比較し、新しい情報があれば自身の情報を更新。 ノードは、自身の情報を他のノードに送信。すべての情報を送信するのではなく、変更された情報のみを送る。 ノードは、他のノードから受信した情報を受け入れ、自身の情報を更新。 演習 $ nodetool gossipinfo localhost/127.0.0.1 generation:1686366680 heartbeat:8156 STATUS:19:NORMAL,-1868919513406135542 LOAD:8135:1.2650205E7 SCHEMA:223:8aec9840-06b7-356a-b5ed-07e43a42d65e DC:9:datacenter1 RACK:11:rack1 RELEASE_VERSION:6:4.1.2 RPC_ADDRESS:5:127.0.0.1 NET_VERSION:2:12 HOST_ID:3:349d6a93-038a-45a9-bd86-cc22ed3d8e0d RPC_READY:21:true NATIVE_ADDRESS_AND_PORT:4:127.0.0.1:9042 STATUS_WITH_PORT:18:NORMAL,-1868919513406135542 SSTABLE_VERSIONS:7:big-nb TOKENS:17:&amp;lt;hidden&amp;gt; ノードの状態はキーバリューペアとして表される。 2ノードある場合、ノード1でnodetool gossipinfoコマンドを実行しても、ノード1とノード2のGossip状態を確認することができる。</description>
    </item>
    <item>
      <title>DS201の実施_Node</title>
      <link>https://yuhi-sa.github.io/posts/20230516_dse_cassandra/6/</link>
      <pubDate>Sat, 10 Jun 2023 09:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20230516_dse_cassandra/6/</guid>
      <description>DS201: Foundations of Apache Cassandra™ and DataStax Enterpriseの学習記録。&#xA;nodetoolはApache Cassandraの管理ツールの一部で、Cassandraクラスターの実行時操作や監視をサポートする。&#xA;代表的なコマンド helpコマンド $ nodetool help usage: nodetool [(-pp | --print-port)] [(-p &amp;lt;port&amp;gt; | --port &amp;lt;port&amp;gt;)] [(-pwf &amp;lt;passwordFilePath&amp;gt; | --password-file &amp;lt;passwordFilePath&amp;gt;)] [(-pw &amp;lt;password&amp;gt; | --password &amp;lt;password&amp;gt;)] [(-h &amp;lt;host&amp;gt; | --host &amp;lt;host&amp;gt;)] [(-u &amp;lt;username&amp;gt; | --username &amp;lt;username&amp;gt;)] &amp;lt;command&amp;gt; [&amp;lt;args&amp;gt;] The most commonly used nodetool commands are: assassinate Forcefully remove a dead node without re-replicating any data. Use as a last resort if you cannot removenode bootstrap Monitor/manage node&amp;#39;s bootstrap process cleanup Triggers the immediate cleanup of keys no longer belonging to a node.</description>
    </item>
    <item>
      <title>DS201の実施_Ring</title>
      <link>https://yuhi-sa.github.io/posts/20230516_dse_cassandra/7/</link>
      <pubDate>Sat, 10 Jun 2023 09:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20230516_dse_cassandra/7/</guid>
      <description>DS201: Foundations of Apache Cassandra™ and DataStax Enterpriseの学習記録。&#xA;Ringとは Cassandraのアーキテクチャは、複数のノードで形成されるクラスタを基盤としている。 その中心にあるデータ構造はRingと呼ばれる。Ringとは、クラスタ内でデータがどのように各ノード間で分散されるかを管理する役割を担っている。&#xA;Cassandraは全てのデータをパーティションに分割し、それぞれのパーティションに一意のトークンを割り当てる。これらのトークンは、Ringのデータ構造の中に配列される。Ringとは、全ての可能なトークンの値の範囲を視覚化したものといえる。&#xA;各ノードは、Ring上の特定の範囲のトークンを所有している。その所有するトークン範囲に対応するデータの一部を格納することにより、どのデータがどのノードに存在するかが決定され、データがノード間で分散される。&#xA;リングの構造は、ノードが追加または削除されたときにも、データの再分配を最小限に抑える役割も果たす。新たなノードが追加された際には、そのノードはリング上の特定の位置を占め、既存の隣接するノードからデータの一部を引き継ぐ。これにより、新規に追加されたノードが新たなデータの保存場所として機能する。&#xA;Ringの構造は単一障害点を排除する役割も果たす。1つのノードが故障またはダウンしても、他のノードがその役割を引き継ぎ、システムは正常に動作し続ける。これは各ノードがデータの一部を保有し、それぞれが特定のトークン範囲を所有しているためである。&#xA;Cassandraのリング構造は、データの一貫性と高可用性を保証するためのレプリケケーションとしても機能する。各パーティションのデータは、Ring上の複数のノードに複製される。通常、所有するトークンが隣接するノードに対して行われる。この複製プロセスにより、ノードが故障してもデータが失われることがなく、また必要なデータが常に読み出せる状態が保たれる。&#xA;このように、Cassandraのリングは、データの配置、スケーラビリティ、耐障害性、および一貫性という、分散データベースの主要な課題を管理するための強力な仕組みである。&#xA;演習 「datastax」と「cassandra」の2つのタグがそれぞれ1つのパーティションを形成している。 cqlshクエリの結果である&amp;quot;system.token(tag)&amp;ldquo;の値は、各タグ（&amp;ldquo;datastax&amp;quot;および&amp;quot;cassandra&amp;rdquo;）に対応するトークンの値を示している。&#xA;cqlsh:killrvideo&amp;gt; SELECT token(tag), tag ... FROM videos_by_tag; system.token(tag) | tag ----------------------+----------- -1651127669401031945 | datastax -1651127669401031945 | datastax 356242581507269238 | cassandra 356242581507269238 | cassandra 356242581507269238 | cassandra nodetool ringの出力は、Cassandraクラスタ内のノードの情報を示している。各行は1つのノードを表し、そのノードが保持しているトークンの値が表示している。nodetool コマンドによって表示されるトークンは、ノードが担当するデータの範囲の開始トークンである。&#xA;$ nodetool ring Datacenter: datacenter1 ========== Address Rack Status State Load Owns Token 8495111347830785616 127.0.0.1 rack1 Up Normal 12.04 MiB 100.00% -9107256078387604241 127.</description>
    </item>
    <item>
      <title>DS201の実施_VNode</title>
      <link>https://yuhi-sa.github.io/posts/20230516_dse_cassandra/8/</link>
      <pubDate>Sat, 10 Jun 2023 09:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20230516_dse_cassandra/8/</guid>
      <description>DS201: Foundations of Apache Cassandra™ and DataStax Enterpriseの学習記録。&#xA;従来のCassandraの設計では、物理ノードがデータのパーティションを管理していた。しかし、物理ノードが故障した場合、そのノードが担当していたパーティションを別のノードに再分配する必要がある。この再分配は手間がかかり、時間とリソースを消費する。&#xA;そこで、CassandraではVNode（仮想ノード）が導入さた。VNodeは、パーティションを物理ノード間で均等に分散する仕組みである。VNodeでは、物理ノードごとに複数の仮想ノードが作成される。各仮想ノードは一意のトークン範囲を持ち、その範囲内のパーティションを担当する。つまり、データは仮想ノードに均等に分散されるため、物理ノードの追加や故障に対して柔軟に対応できる。&#xA;VNodeを使用することで、Cassandraクラスターのパフォーマンスと可用性が向上し、管理の負担が軽減される。</description>
    </item>
    <item>
      <title>DS201の実施_ClusteringColumns</title>
      <link>https://yuhi-sa.github.io/posts/20230516_dse_cassandra/4/</link>
      <pubDate>Sat, 20 May 2023 09:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20230516_dse_cassandra/4/</guid>
      <description>DS201: Foundations of Apache Cassandra™ and DataStax Enterpriseの学習記録。&#xA;クラスタリングカラムとは、主キーの一部であるが、パーティションキーではないカラムのこと。&#xA;クラスタリングカラムを指定してテーブル作成 CREATE TABLE videos_by_tag ( tag text, video_id uuid, added_date timestamp, title text, PRIMARY KEY ((tag), added_date, video_id) ) WITH CLUSTERING ORDER BY(added_date DESC); データを入れた後、中身を確認 cqlsh:killrvideo&amp;gt; SELECT * ... FROM videos_by_tag; tag | added_date | video_id | title -----------+---------------------------------+--------------------------------------+------------------------------ datastax | 2013-10-16 09:00:00.000000+0000 | 4845ed97-14bd-11e5-8a40-8338255b7e33 | DataStax Studio datastax | 2013-04-16 09:00:00.000000+0000 | 5645f8bd-14bd-11e5-af1a-8638355b8e3a | What is DataStax Enterprise? cassandra | 2014-01-29 09:00:00.</description>
    </item>
    <item>
      <title>DS201の実施_Drivers</title>
      <link>https://yuhi-sa.github.io/posts/20230516_dse_cassandra/5/</link>
      <pubDate>Sat, 20 May 2023 09:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20230516_dse_cassandra/5/</guid>
      <description>DS201: Foundations of Apache Cassandra™ and DataStax Enterpriseの学習記録。&#xA;Pythonドライバを使用してApache Cassandraに接続する。&#xA;from cassandra.cluster import Cluster cluster = Cluster(protocol_version = 3) session = cluster.connect(&amp;#39;killrvideo&amp;#39;) for val in session.execute(&amp;#34;SELECT * FROM videos_by_tag&amp;#34;): print(val) $ python test.py Row(tag=&amp;#39;datastax&amp;#39;, added_date=datetime.datetime(2013, 10, 16, 9, 0), video_id=UUID(&amp;#39;4845ed97-14bd-11e5-8a40-8338255b7e33&amp;#39;), title=&amp;#39;DataStax Studio&amp;#39;) Row(tag=&amp;#39;datastax&amp;#39;, added_date=datetime.datetime(2013, 4, 16, 9, 0), video_id=UUID(&amp;#39;5645f8bd-14bd-11e5-af1a-8638355b8e3a&amp;#39;), title=&amp;#39;What is DataStax Enterprise?&amp;#39;) Row(tag=&amp;#39;cassandra&amp;#39;, added_date=datetime.datetime(2014, 1, 29, 9, 0), video_id=UUID(&amp;#39;1645ea59-14bd-11e5-a993-8138354b7e31&amp;#39;), title=&amp;#39;Cassandra History&amp;#39;) Row(tag=&amp;#39;cassandra&amp;#39;, added_date=datetime.datetime(2013, 3, 17, 9, 0), video_id=UUID(&amp;#39;3452f7de-14bd-11e5-855e-8738355b7e3a&amp;#39;), title=&amp;#39;Cassandra Intro&amp;#39;) Row(tag=&amp;#39;cassandra&amp;#39;, added_date=datetime.</description>
    </item>
    <item>
      <title>DS201の実施_CQL</title>
      <link>https://yuhi-sa.github.io/posts/20230516_dse_cassandra/2/</link>
      <pubDate>Tue, 16 May 2023 09:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20230516_dse_cassandra/2/</guid>
      <description>DS201: Foundations of Apache Cassandra™ and DataStax Enterpriseの学習記録。&#xA;CQLshellを起動 $ cqlsh cqlsh: Cassandraのクエリ言語シェル。Cassandraクラスターに接続し、CQL（Cassandra Query Language）を使用してデータベース操作を行う。&#xA;keyspaceの作成 killrvideo という名前の keyspace を作成。&#xA;cqlsh&amp;gt;　CREATE KEYSPACE killrvideo WITH replication = { &amp;#39;class&amp;#39;:&amp;#39;SimpleStrategy&amp;#39;, &amp;#39;replication_factor&amp;#39;: 1 }; keyspace：Cassandraにおけるデータベースのトップレベルのコンテナ。データの論理的なグループ化を提供し、テーブルやデータの構造を定義する。 replication：キースペース内のデータの冗長複製を管理する方法を指定する。 keyspaceの選択 cqlsh&amp;gt;　USE killrvideo; tableの作成 cqlsh:killrvideo&amp;gt;　CREATE TABLE videos ( video_id TIMEUUID, added_date TIMESTAMP, title TEXT, PRIMARY KEY (video_id) ); cqlsh:killrvideo&amp;gt; INSERT INTO videos (video_id, added_date, title) cqlsh:killrvideo&amp;gt; VALUES (1645ea59-14bd-11e5-a993-8138354b7e31, &amp;#39;2014-01-29&amp;#39;, &amp;#39;Cassandra History&amp;#39;); データ確認 cqlsh:killrvideo&amp;gt; SELECT * FROM videos; video_id | added_date | title --------------------------------------+---------------------------------+------------------- 1645ea59-14bd-11e5-a993-8138354b7e31 | 2014-01-28 15:00:00.</description>
    </item>
    <item>
      <title>DS201の実施_partitions</title>
      <link>https://yuhi-sa.github.io/posts/20230516_dse_cassandra/3/</link>
      <pubDate>Tue, 16 May 2023 09:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20230516_dse_cassandra/3/</guid>
      <description>DS201: Foundations of Apache Cassandra™ and DataStax Enterpriseの学習記録。&#xA;パーティション（Partition）は、データを分割して格納するための概念。&#xA;パーティションは、データの格納と検索の単位となる。Cassandraのテーブルは、1つまたは複数のパーティションで構成されており、各パーティションは一意のパーティションキーによって識別される。パーティションキーは、データを分割するための基準となる。パーティションキーの値に基づいてデータが物理的に分散される。&#xA;cqlsh:killrvideo&amp;gt; DESCRIBE TABLE videos; CREATE TABLE killrvideo.videos ( video_id timeuuid PRIMARY KEY, added_date timestamp, title text ) WITH additional_write_policy = &amp;#39;99p&amp;#39; AND bloom_filter_fp_chance = 0.01 AND caching = {&amp;#39;keys&amp;#39;: &amp;#39;ALL&amp;#39;, &amp;#39;rows_per_partition&amp;#39;: &amp;#39;NONE&amp;#39;} AND cdc = false AND comment = &amp;#39;&amp;#39; AND compaction = {&amp;#39;class&amp;#39;: &amp;#39;org.apache.cassandra.db.compaction.SizeTieredCompactionStrategy&amp;#39;, &amp;#39;max_threshold&amp;#39;: &amp;#39;32&amp;#39;, &amp;#39;min_threshold&amp;#39;: &amp;#39;4&amp;#39;} AND compression = {&amp;#39;chunk_length_in_kb&amp;#39;: &amp;#39;16&amp;#39;, &amp;#39;class&amp;#39;: &amp;#39;org.apache.cassandra.io.compress.LZ4Compressor&amp;#39;} AND memtable = &amp;#39;default&amp;#39; AND crc_check_chance = 1.</description>
    </item>
    <item>
      <title>ローカルmacへのCassandraインストール</title>
      <link>https://yuhi-sa.github.io/posts/20230516_dse_cassandra/1/</link>
      <pubDate>Tue, 16 May 2023 09:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20230516_dse_cassandra/1/</guid>
      <description>Cassandraインストール&#xA;$ brew install cassandra Cassandraサーバーを起動&#xA;$ brew services start cassandra CQLshellを起動&#xA;$ cqlsh </description>
    </item>
    <item>
      <title>AWS Summit Tokyo 2023に行った</title>
      <link>https://yuhi-sa.github.io/posts/20230420_aws_summit/1/</link>
      <pubDate>Thu, 20 Apr 2023 09:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20230420_aws_summit/1/</guid>
      <description>概要 以下のイベントに参加してきた。&#xA;10:30に行ったら、わりとスムーズに中に入れた。10:00までに行くと特典があってTwitterで見てた感じ、混んでたよう。&#xA;イベント名：AWS Summit Tokyo 日付：2023年4月20日、21日 場所：幕張メッセ 入り口 受講票を印刷して持ってきてくださいと言われていて、なぜ印刷なんだろうと思っていたが、名札に入れるためのようだった。(忘れてもその場で印刷してもらえる。) ここにのっているQRコード読み込んでセミナーとかの管理をしてた。&#xA;基調講演 ブース わりと1対1で話が聞けて勉強になった。&#xA;セミナー トランシーバーで話を聞くセミナー初めてだった。予約では満員になっていたセミナーでも当日入場で普通に入れた。&#xA;グッズ ブースを巡ってたら色々もらえた。&#xA;野村総合研究所&#xA;クラウドストライク&#xA;AWS&#xA;PagerDuty&#xA;Dynatrace&#xA;denode&#xA;vmware&#xA;beepplus</description>
    </item>
    <item>
      <title>メールにおける認証技術</title>
      <link>https://yuhi-sa.github.io/posts/20230328_mail_auth/1/</link>
      <pubDate>Tue, 28 Mar 2023 09:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20230328_mail_auth/1/</guid>
      <description>&#xA;通信路の暗号化 SMTP(Simple Mail Transfer Protocol) over TLS SMTP (Simple Mail Transfer Protocol) over TLSを使用して、SMTP通信を暗号化する。TLSを使用することで、通信経路上の第三者による盗聴や改竄を防ぐことができる。ただし、終端（メールサーバー）で復号化されるため、メールサーバーにアクセスされる場合には注意が必要。&#xA;送信者メールサーバーが送信者を認証 SMTP Auth SMTP Authではユーザー名とパスワードを使い、送信者の認証を行う。チャレンジレスポンス方式により、ユーザー名とパスワードを使って認証を行う。&#xA;受信側のメールサーバーが送信側のメールサーバーを認証 SPF(Sender Policy Framework)：IPアドレス方式 SPFは、送信者のDNSサーバーにSPFレコードを登録することで、受信側のメールサーバーが送信者を認証する。受信側のメールサーバーは、送信者のDNSサーバーに問い合わせてSPFレコードを取得し、IPアドレスを比較することで認証を行う。&#xA;DKIM(DomainKeys Identified Main)：デジタル署名方式 DKIMは、送信者のDNSサーバーに公開鍵を登録することで、受信側のメールサーバーが送信者を認証する仕組み。送信者はメールにデジタル署名を付与して送信し、受信側のメールサーバーは送信者のDNSサーバーに問い合わせて公開鍵を取得し、検証を行う。&#xA;受信者が送信者を認証 S/MIME(Secure / Multipurpose Internet Mail Extensions) S/MIMEは、デジタル署名を用いてメールを暗号化する方法。送信者は、メールにデジタル署名を付与して送信し、受信者は、署名を検証して送信者を認証する。&#xA;PGP(Pretty Good Privacy) PGPは、公開鍵の交換を事前に当事者間で行い、メールにデジタル署名を付与して送信することで、送信者を認証する方法。&#xA;参考 ２０２３　情報処理安全確保支援士「専門知識＋午後問題」の重点対策 </description>
    </item>
    <item>
      <title>シングルサインオン(SSO)</title>
      <link>https://yuhi-sa.github.io/posts/20230105_sec/2/</link>
      <pubDate>Tue, 03 Jan 2023 09:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20230105_sec/2/</guid>
      <description>シングルサインオン(SSO) 独立して稼働している複数のシステムに対してログインする場合、それぞれのIDとパスワードを使用する必要がある。一度ログインするだけで、複数のシステムにアクセスできるようにすることをシングルサインオンと呼ぶ。&#xA;実現方法として以下のようなものがある。&#xA;エージェント方式：各サーバにエージェントをインストールしておく方式。 リバースプロキシ方式：リバースプロキシを通して各サーバにアクセスする方式。 代理認証方式：プロキシサーバが端末の代わりにIDとパスワードを各サーバに送信する方式。 ID連携(IDフェデレーション) 上記の認証はCookieを使って実現されるが、Cookieの利用に制限をかけることが難しいため、閉じられたネットワークでの利用が主流であった。しかし、さまざまなクラウドサービスが増加したことからID連携が注目されている。&#xA;ID連携において主要なプロトコルには以下のようなものがある。&#xA;SAML：認証のプロトコル OAuth2.0：認可のプロトコル OIDC：OAuthに認証の機能を追加し拡張したプロトコル 参考 2023 情報処理安全確保支援士「専門知識＋午後問題」の重点対策 </description>
    </item>
    <item>
      <title>チャレンジレスポンス方式</title>
      <link>https://yuhi-sa.github.io/posts/20230105_sec/1/</link>
      <pubDate>Tue, 03 Jan 2023 09:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20230105_sec/1/</guid>
      <description>概要 チャレンジレスポンス方式は、セキュリティを強化するために使用される認証方式の一つである。 パスワードを送信することなく、クライアントのIDのみを認証サーバに送信する。&#xA;パスワードが送信されることがないため、第三者による盗聴や攻撃からのリスクが低くなる。&#xA;チャレンジレスポンス方式の流れ [クライアント]利用者がIDとパスワードを入力すると、IDのみを認証サーバに送信 [認証サーバ]乱数を生成し、チャレンジコードとしてクライアントに送信 [クライアント]パスワードとチャンレンジコードを基にハッシュ関数でハッシュ値を生成し、認証サーバに送信 [認証サーバ]チャレンジコードと管理しているパスワードのハッシュ値を計算し、送られてきたハッシュ値と照合 参考 2023 情報処理安全確保支援士「専門知識＋午後問題」の重点対策 </description>
    </item>
    <item>
      <title>Vimの使い方メモ</title>
      <link>https://yuhi-sa.github.io/posts/20221230_vim/1/</link>
      <pubDate>Fri, 30 Dec 2022 09:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20221230_vim/1/</guid>
      <description>Vimの基本操作 モード切り替え i：インサートモード etc：ノーマルモード view：ビューモード ノーマルモードでの移動 k：↑に移動 j：↓に移動 h：←に移動 l：→に移動 {：段落ごとに上に移動 }：段落ごとに下に移動 gg：ファイルの先頭に移動 終了 :w：上書き保存 :q：編集終了 :q!：保存しないで終了 :wq：保存して終了 ノーマルモードでの操作 x：一文字削除 dd：一行削除 dw：単語削除 2 dd：二行削除 u：undo control+r：undo redo yy：一行コピー p：下にペースト P：現在行にペースト 2yy：2行コピー .：Repeat 検索や置換 /{検索内容}：検索 n：次の検索結果に移動 N：前の検索結果に移動 %s/{置換前}/{置換後}/g：一括置換 %s/{置換前}/{置換後}/gc：一括置換 その他 o：下に空白を入れてインサートモード O：選択行に空白を入れてインsタートモード J：行の連結 Vimのプラグイン Vim Plug vimのプラグインマネージャー https://github.com/junegunn/vim-plug vim horizon vimの色合いを変更するプラグイン https://github.com/ntk148v/vim-horizon Nerd tree ディレクトリツリーを表示するプラグイン https://github.com/preservim/nerdtree FZF ファイルの検索ができるプラグイン https://github.com/junegunn/fzf Vim-fugitive Gitのコミット履歴が簡単に確認できるプラグイン https://github.com/tpope/vim-fugitive vim-gitgutter Gitの変更差分を表示できるプラグイン https://github.com/airblade/vim-gitgutter Vim-commentary gccコマンドでコメントアウトできるプラグイン https://github.com/tpope/vim-commentary Coc-nvim コードの補完ができるプラグイン https://github.com/neoclide/coc.nvim 設定ファイル set shell=/bin/zsh set shiftwidth=4 set tabstop=4 set expandtab set textwidth=0 set autoindent set hlsearch set clipboard=unnamed syntax on call plug#begin() Plug &amp;#39;ntk148v/vim-horizon&amp;#39; Plug &amp;#39;preservim/nerdtree&amp;#39; Plug &amp;#39;junegunn/fzf&amp;#39;, { &amp;#39;do&amp;#39;: { -&amp;gt; fzf#install() } } Plug &amp;#39;neoclide/coc.</description>
    </item>
    <item>
      <title>JavaScriptの非同期処理(コールバック地獄/Promise/Async関数)</title>
      <link>https://yuhi-sa.github.io/posts/20221229_async_await/1/</link>
      <pubDate>Thu, 29 Dec 2022 09:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20221229_async_await/1/</guid>
      <description>JavaScriptで非同期処理が重要な理由 シングルスレッド JavaScriptはシングルスレッドで動作する。そのため一度に実行できるタスクは1つだけとなる。 JavaScriptは、レイアウト・再フロー・ガベージコレクションなどと同じスレッドで実行される。&#xA;そのため、JavaScript関数がスレッドを占有すると、ページの反応が悪くなるという問題が発生する。 この問題を非同期関数を用いて緩和する。&#xA;参考 JavaScript | MDN Main thread (メインスレッド) | MDN 非同期処理:Promise/Async Function | jsprimer 非同期関数 非同期処理はコードを順番に処理するが、1つの非同期処理が終わるのを待たずに次の処理を行う。 これにより複数の処理を並列に実行している。&#xA;イベントループ JavaScriptエンジン(v8など)は、非同期関数をイベントループを用いて実行する。 JavaScriptエンジンは、主に以下の3つによって構成されている。&#xA;Javascriptエンジン ヒープ領域：動的に確保と解放を繰り返せるメモリ領域 コールスタック：LIFOで呼び出された関数を保存する領域。格納された関数は順次処理される。 WebAPIs ブラウザに搭載されている各種API(DOM, Ajax, timerなど)&#xA;イベントキュー/タスクキュー FIFOで、Web APIから受け取ったCallback関数を保存する&#xA;イベントループは以下の流れで非同期処理を実現する。&#xA;コールスタックとイベントキューを監視し、コールスタックが空になったら、イベントキューの作業を順番にコールスタックに移動させる。 JavaScriptがメモリ上に展開され、コールスタックで実行される。 Web APIsから提供されているAPIを呼び出すと、Web APIsの実行環境で処理が実行する。 非同期関数の呼び出しの場合、Web APIsの実行環境内で、条件を満たすまで待機し、条件を満たすとイベントキューに格納される。 参考 非同期処理 (1):Javascriptの動作の流れ (JS エンジン/Call Stack/Event Queue) | Zenn JavaScriptのイベントループを理解する | Qiita JavaScriptがブラウザでどのように動くのか | mercari engineering 非同期関数の例 たとえば、処理を一時停止させる場合はsetTimeout関数を利用して実現する方法がある。&#xA;// setTimeout(&amp;#39;コールバック関数&amp;#39;, &amp;#39;タイムアウト時間&amp;#39;) function callback(){ console.log(&amp;#39;test&amp;#39;) } 非同期処理が複数重なると、コールバック地獄になり、ネストが深く処理が追いづらくなる。&#xA;setTimeout(callback, 1) setTimeout(() =&amp;gt; { console.</description>
    </item>
    <item>
      <title>webpackとbabelでReactを使える環境を作成する</title>
      <link>https://yuhi-sa.github.io/posts/20221111_react/1/</link>
      <pubDate>Fri, 11 Nov 2022 09:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20221111_react/1/</guid>
      <description>webpack JavaScriptのモジュールバンドラー。&#xA;Webpackでビルドすることでnode_modulesの依存関係を解消し、1つのJSファイルにまとめることができる。&#xA;JSのモジュールとbabelとwebpackとは何かまとめてみる（初心者向け） Babel JavaScriptのトランスコンパイラー。&#xA;元々はES6のコードをES5に変換するため「6to5」という名前で作成された。&#xA;新記法で書かれたコードを、それらの機能をサポートしていないブラウザでも動く古記法のコードに変換することができる。&#xA;Babelとは ES6からES5への変換ツール「6to5」が名称を「Babel」に変更 環境構築 以下の記事を参考に作成した。&#xA;React 環境構築　Webpack + Babelなぜ必要？ WebpackとBabelでReact.js 構築　設定 webpack + babel + TypeScript + React メモ 必要なモジュールのインストール mkdir react_test cd react_test # プロジェクトの初期化 npm init -y # Babelを使用するのに必要なモジュール npm i -D @babel/core # Babel本体 npm i -D @babel/preset-env # 必要なプラグインを自動で選択して変換処理しれくれるpresets npm i -D　@babel/preset-react @babel/preset-typescript　# React, Typescript用 # Webpackを使用するのに必要なモジュールなど npm i -D webpack webpack-cli babel-loader ts-loader npm i -D webpack-dev-server html-webpack-plugin # Reactを使用するのに必要なモジュールを追加 npm i -S react react-dom # jsxコードを使用してReactを記述する npm i -D typescript @types/react @types/react-dom # tsconfig.</description>
    </item>
    <item>
      <title>Kubernetesの認証情報(Context)</title>
      <link>https://yuhi-sa.github.io/posts/20220831_k8s/5/</link>
      <pubDate>Sun, 04 Sep 2022 10:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20220831_k8s/5/</guid>
      <description>kubeconfig kubectlが、k8s Masterと通信する際には、接続先サーバのの認証情報を「~/.kube/confg」に記載する必要がある。&#xA;kubeconfigで具体的な設定を行う部分は、clusters、users、contextsの三種類あり、配列型で設定する。 clustersには接続先クラスタの情報を、usersには認証情報を定義する。contextsはclusterとuserのペアとnamespaceを指定したものを定義する。&#xA;apiVersion: v1 kind: Config clusters: # 接続先クラスタ情報 - cluster: certificate-authority: /Users/USER/.minikube/ca.crt extensions: - extension: last-update: Thu, 01 Sep 2022 09:39:29 JST provider: minikube.sigs.k8s.io version: v1.26.1 name: cluster_info server: https://127.0.0.1:55537 name: minikube users: # 認証情報 - name: minikube user: client-certificate: /Users/USER/.minikube/profiles/minikube/client.crt client-key: /Users/USER/.minikube/profiles/minikube/client.key contexts:　＃接続先と認証情報の組み合わせ - context: cluster: minikube extensions: - extension: last-update: Thu, 01 Sep 2022 09:39:29 JST provider: minikube.sigs.k8s.io version: v1.26.1 name: context_info namespace: default user: minikube name: minikube current-context: docker-desktop preferences: {} kubeconfigの操作 contextを切り替えることで複数の環境を複数の権限で扱えるようになる。</description>
    </item>
    <item>
      <title>Kubernetesのリソースカテゴリ</title>
      <link>https://yuhi-sa.github.io/posts/20220831_k8s/3/</link>
      <pubDate>Thu, 01 Sep 2022 10:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20220831_k8s/3/</guid>
      <description>Workloads APIsカテゴリ コンテナの実行に関わるリソースで以下の8種類が存在する。&#xA;Pod ReplicationController ReplocaSet Deployment DaemonSet StatefulSet CronJob Service APIsカテゴリ コンテナを外部公開するリソースで、利用者が直接利用するものとしてはServiceとIngressの2種類が存在する。&#xA;Service ClusterIP ExternalIP NodePort LoadBalancer Headless ExternalName None-Selector Ingress Config &amp;amp; Storage APIsカテゴリ 設定、機密情報、永続化ボリュームに関するリソースでSecretとConfigMap、PersistentVolumeClaimが存在する。 SecretとConfigMapはKey-Value形式でデータを持ち、ersistentVolumeClaimは永続ボリュームを要求する時に利用する。&#xA;Secret ConfigMap PersistentVolumeClaim Cluster APIsカテゴリ セキュリティやクォータに関するリソースで、クラス自体の振る舞いを定義する。&#xA;Node Namespace PersistentVolume ResourceQuota ServiceAccount Role ClusterRole RoleBinding ClusterRoleBinding NetworkPolicy Metadata APIs カテゴリ クラスタ内の他のリソースを操作するためのリソース。&#xA;LimitRange HorizontalPodAutoscaler PodDisruptionBudget CustomResourceDefinition 参考 青山真也,Kubernetes完全ガイド 第2版 impress top gearシリーズ </description>
    </item>
    <item>
      <title>Kubernetesの初期状態のNamespace</title>
      <link>https://yuhi-sa.github.io/posts/20220831_k8s/4/</link>
      <pubDate>Thu, 01 Sep 2022 10:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20220831_k8s/4/</guid>
      <description>kubernetes(k8s)では初期状態で以下の4つのNameSpaceが作成される。&#xA;kube-system k8sクラスタのコンポーネントやアドオンがデプロイされるNameSpace&#xA;Dashboardやアドオンなど&#xA;kube-public 全ユーザが利用できるConfigMapなどを配置するNameSpace&#xA;kube-node-lease ノードのハードビート情報が保存されるNameSpace&#xA;default デフォルトのNamespace&#xA;参考 青山真也,Kubernetes完全ガイド 第2版 impress top gearシリーズ </description>
    </item>
    <item>
      <title>dockerファイルの命令文</title>
      <link>https://yuhi-sa.github.io/posts/20220831_k8s/1/</link>
      <pubDate>Wed, 31 Aug 2022 10:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20220831_k8s/1/</guid>
      <description>FROM ベースイメージを指定&#xA;LABEL コンテナイメージのメタデータを指定&#xA;USER コマンドの実行ユーザーを指定&#xA;WORKDIR コマンドを実行する作業ディレクトリを指定&#xA;EXPOSE コンテナ起動時に公開するポートを指定&#xA;COPY ローカルにあるファイルをコンテナにコピーして配置&#xA;RUN ビルド時にコンテナ上でコマンドを実行する命令&#xA;ENTRYPOINT コンテナ起動時に実行するデフォルトコマンド&#xA;CMD コンテナ起動時に実行するデフォルトコマンドの引数 →「$ENTRYPOINT $CMD」という形で実行される&#xA;参考 青山真也,Kubernetes完全ガイド 第2版 impress top gearシリーズ </description>
    </item>
    <item>
      <title>Kubernetesをローカル環境に構築する</title>
      <link>https://yuhi-sa.github.io/posts/20220831_k8s/2/</link>
      <pubDate>Wed, 31 Aug 2022 10:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20220831_k8s/2/</guid>
      <description>Kubernetes(k8s)とは コンテナ化されたアプリケーションのデプロイ、スケーリングなどの管理を自動化するプラットフォーム。 k8sでは、コンテナが起動するノードをk8sノードと呼び、それらを管理するノードk8sマスターと呼ぶ。ノードの集合体がk8sクラスターである。&#xA;Minikube MinikubeはSIG-Cluster-Lifecycleで作られた簡単にローカルにk8sクラスターを構築・実行できるツールである。 Minikubeではローカルの仮装マシン上にk8sをインストールするため、ハイパーバイザーが必要となる。&#xA;ハイパーバイザーごとに応じたDriverを使用して操作することで、自動的にホストとなるコンテナや仮想マシンを作成し、 その環境上にk8sをインストールする。&#xA;macOSにおけるハイパーバイザーにはDocker/HyperKit driver/VirtualBox/Parallels/Vmware/Fusion/Podmanなどがある。&#xA;現状、M1macではdockerしか対応してなさそう、、？&#xA;M1 MacにおけるHyperkitとそれが必要なアプリケーションの利用について Minikubeのインストール $ brew install minikube ==&amp;gt; Downloading https://ghcr.io/v2/homebrew/core/kubernetes-cli/manifests/1.25.0 ######################################################################## 100.0% ==&amp;gt; Downloading https://ghcr.io/v2/homebrew/core/kubernetes-cli/blobs/sha256:e10 ==&amp;gt; Downloading from https://pkg-containers.githubusercontent.com/ghcr1/blobs/sh ######################################################################## 100.0% ==&amp;gt; Downloading https://ghcr.io/v2/homebrew/core/minikube/manifests/1.26.1 ######################################################################## 100.0% ==&amp;gt; Downloading https://ghcr.io/v2/homebrew/core/minikube/blobs/sha256:ae9660e6a ==&amp;gt; Downloading from https://pkg-containers.githubusercontent.com/ghcr1/blobs/sh ######################################################################## 100.0% ==&amp;gt; Installing dependencies for minikube: kubernetes-cli ==&amp;gt; Installing minikube dependency: kubernetes-cli ==&amp;gt; Pouring kubernetes-cli--1.25.0.arm64_monterey.bottle.tar.gz 🍺 /opt/homebrew/Cellar/kubernetes-cli/1.25.0: 228 files, 52.8MB ==&amp;gt; Installing minikube ==&amp;gt; Pouring minikube--1.</description>
    </item>
    <item>
      <title>pythonを用いたjsonを返却する簡易mockserver</title>
      <link>https://yuhi-sa.github.io/posts/20220716_python_mock_server/1/</link>
      <pubDate>Sat, 16 Jul 2022 15:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20220716_python_mock_server/1/</guid>
      <description>WSGI (Web Server Gateway Interface) を用いてWeb サーバを起動する from wsgiref.simple_server import make_server import json PORT = 8081 SETTING = [{&amp;#34;PATH&amp;#34;:&amp;#34;/api/1&amp;#34;,&amp;#34;VALUE&amp;#34;: {&amp;#34;items&amp;#34;:[ {&amp;#34;item1&amp;#34;:&amp;#34;test1&amp;#34;}, {&amp;#34;item2&amp;#34;:&amp;#34;test2&amp;#34;} ]}}, {&amp;#34;PATH&amp;#34;:&amp;#34;/api/2&amp;#34;,&amp;#34;VALUE&amp;#34;: {&amp;#34;items2&amp;#34;:[ {&amp;#34;itemA&amp;#34;:&amp;#34;test1&amp;#34;}, {&amp;#34;itemB&amp;#34;:&amp;#34;test2&amp;#34;} ]}} ] def app(environ, start_response): path = environ[&amp;#34;PATH_INFO&amp;#34;] for setting in SETTING: if path.startswith(setting[&amp;#34;PATH&amp;#34;]): status = &amp;#39;200 OK&amp;#39; headers = [ (&amp;#39;Content-type&amp;#39;, &amp;#39;application/json; charset=utf-8&amp;#39;), (&amp;#39;Access-Control-Allow-Origin&amp;#39;, &amp;#39;*&amp;#39;), ] start_response(status, headers) return [json.dumps( setting[&amp;#34;VALUE&amp;#34;] ).encode(&amp;#34;utf-8&amp;#34;)] if __name__ == &amp;#34;__main__&amp;#34;: httpd = make_server(&amp;#39;&amp;#39;, PORT, app) httpd.serve_forever() 参考 標準ライブラリの範囲でpythonでweb APIのmock serverが欲しくなった場合 wsgiref &amp;mdash; WSGI ユーティリティとリファレンス実装 </description>
    </item>
    <item>
      <title>踏み台サーバー経由で多段ssh</title>
      <link>https://yuhi-sa.github.io/posts/20220716_ssh/1/</link>
      <pubDate>Sat, 16 Jul 2022 15:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20220716_ssh/1/</guid>
      <description>sshコマンド ssh -o ProxyCommand=&amp;#39;ssh 踏み台 nc %h %p&amp;#39; アクセス先 </description>
    </item>
    <item>
      <title>Python(boto3)を用いたAWS利用のためセットアップメモ(S3の起動とAIサービスの利用)</title>
      <link>https://yuhi-sa.github.io/posts/20220220_aws_set/1/</link>
      <pubDate>Sun, 20 Feb 2022 15:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20220220_aws_set/1/</guid>
      <description>AWSのセットアップ AWSに登録 https://aws.amazon.com/ IAMユーザーコンソールを開く グループを作成 # サンプル グループ名：admin ポリシー：AdoministratorAccess ユーザーの追加&#xA;アクセスキーIDとシークレットアクセスキーをメモ シークレットアクセスキーはこの時しか表示されない Python環境のセットアップ AWS CLIをインストール&#xA;$ pip install awscli アクセスキーを設定&#xA;$ aws configure 設定事項&#xA;AWS Access Key ID [****************]: [アクセスキーID] AWS Secret Access Key [************]: [アクセスキーID] Default region name [ap-northeast-1]: ap-northeast-1 Default output format [json]: json Boto3をインストール&#xA;$ pip install boto3 その他&#xA;以下のコマンドでアクセスキーIDとアクセスキーIDを確認できる&#xA;$ aws configure get aws_access_key_id $ aws configure get aws_secret_access_key S3(Simple Storage Service)の起動 バケットの作成 import boto3 import random s3 = boto3.</description>
    </item>
    <item>
      <title>リパラメタライゼーショントリック(Reparameterization trick)</title>
      <link>https://yuhi-sa.github.io/posts/20220206_repa/1/</link>
      <pubDate>Sun, 06 Feb 2022 15:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20220206_repa/1/</guid>
      <description>リパラメタライゼーショントリック(Reparameterization trick) 確率分布からサンプリングされた変数は確率変数となるため微分ができず， 逆誤差伝搬による計算を行うことができない． この問題を解決するため、Kingmaらが導入した手法がリパラメタライゼーショントリックである．&#xA;リパラメタライゼーショントリックでは特定の確率分布からのサンプリングをパラメータ非依存の乱数と その確率分布のパラメータに分割・合成することで同等のサンプリングを行う． 例えば，$z$が平均$\mu$，分散$\sigma$をパラメータとして持つ正規分布$\mathcal{N}$からサンプリングされるとする．&#xA;$$z \sim \mathcal{N}(\mu, \sigma^2)$$&#xA;ランダムノイズ$\epsilon$を用いて以下のように変換する．&#xA;$$z = \mu + \sigma \odot \epsilon$$&#xA;$$\epsilon \sim \mathcal{N}(0,1) $$&#xA;これにより$z$は，$\mu$と$\sigma$に対して確定的な値となるため微分可能になる．&#xA;Pytorchでのリパラメタライゼーショントリックを用いたサンプリング m = Normal(*params) z = m.rsample() リパラメタライゼーショントリックを用いたサンプリングができるできる確率分布は以下の値がTrueとなっている．&#xA;m.has_rsample 参考 D. P. Kingma and M. Welling, “Auto-encoding variational bayes”, 2013. ReNom, 変分オートエンコーダ </description>
    </item>
    <item>
      <title>指数移動平均(Exponential Moving Averages)フィルタの周波数特性</title>
      <link>https://yuhi-sa.github.io/posts/20220206_ema/1/</link>
      <pubDate>Sun, 06 Feb 2022 14:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20220206_ema/1/</guid>
      <description>指数移動平均(Exponential Moving Averages;EMA) 入力$x$に対して，平滑化率$\beta$に応じて時系列平滑化を行い$y$を得ることによって時系列データを平滑化する代表的な手法である． 1ステップ前のフィルタリングされたの値と現在の観測値を$\beta$を用いて重み付けし足し合わせることで， 最近のデータを重視するとともに古いデータを完全には切り捨てない仕組みとなっている．&#xA;$$y_t=\beta y_{t-1}+(1-\beta)x_t$$&#xA;ゲイン特性と位相特性 上式をラプラス変換する．&#xA;$$Y(s)=\beta e^{-s}Y(s)+(1-\beta)X(s)$$&#xA;式変形し伝達関数を求める．&#xA;$$G(s)=\frac{Y(s)}{X(s)}=\frac{\beta}{1+(1-\beta)e^{-s}}$$&#xA;$s=jw$とする．&#xA;$$G(jw)= \frac{\beta}{1+(1-\beta)e^{-jw}}$$&#xA;ゲイン特性と位相特性は以下の様になる．&#xA;$$|G(jw)| = \frac{\beta}{\sqrt{1-2(1-\beta) \cos w+(1-\beta)^2}}$$&#xA;$$\angle G(jw) = \tan^{-1} (\frac{-\sin w}{\cos w-(1-\beta)})$$&#xA;$\beta$が小さい場合，周波数帯域が狭く強い平滑化を行うことができるが位相遅れが大きくなる． 一方で$\beta$が大きい場合，位相遅れは小さいが平滑化能力が低下することがわかる．&#xA;プログラム import math import matplotlib.pyplot as plt BETA = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9] LENGE = 300 frequency = [[] for _ in range(len(BETA))] gain = [[] for _ in range(len(BETA))] phase = [[] for _ in range(len(BETA))] def get_gain(beta, w): return beta / math.</description>
    </item>
    <item>
      <title>linuxのログファイルと閲覧コマンド</title>
      <link>https://yuhi-sa.github.io/posts/20211121_linux/6/</link>
      <pubDate>Thu, 30 Dec 2021 10:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20211121_linux/6/</guid>
      <description>代表的なログ messageファイル /var/log/message Linuxシステム全体の情報の記録している．&#xA;secureファイル /var/log/secure/ 認証やセキュリティー関連の情報を記録している．&#xA;wtmpファイル /var/log/wtmp ログイン履歴の記録している．&#xA;lastコマンドで閲覧できる．&#xA;utmpファイル /var/run/utmp ログイン中のユーザーの情報を記録しれいる．&#xA;whoコマンドで閲覧できる．&#xA;lastlogファイル /var/log/lastlog 各ユーザーの最終ログイン日時を記録している．&#xA;lastlogコマンドで閲覧できる．</description>
    </item>
    <item>
      <title>SQLの表の結合</title>
      <link>https://yuhi-sa.github.io/posts/20211121_db/5/</link>
      <pubDate>Thu, 30 Dec 2021 10:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20211121_db/5/</guid>
      <description>内部結合 結合条件を満たす組み合わせのみ表示する結合&#xA;SELECT 列リスト FROM 表名1 JOIN 表名2 ON 表名1.列名 = 表名2.列名 JOINではなくNATURAL JOINを用いると自動的に同じ列名の値を結合キーとして比較できる．このときON句で結合条件を指定する必要はない．&#xA;外部結合 結合条件を満たさない組み合わせも表示する結合&#xA;左外部結合：左側の表を全て表示 SELECT 列リスト FROM 表名1 LEFT OUTER JOIN 表名2 ON 表名1.列名 = 表名2.列名 右外部結合：右側の表を全て表示 SELECT 列リスト FROM 表名1 RIGHT OUTER JOIN 表名2 ON 表名1.列名 = 表名2.列名 クロス結合 全ての組み合わせを表示する結合&#xA;SELECT 列リスト FROM 表名1 CROSS JOIN 表名2 </description>
    </item>
    <item>
      <title>ガウス分布同士のクロスエントロピーの閉形式導出</title>
      <link>https://yuhi-sa.github.io/posts/20211209_nd_ce/1/</link>
      <pubDate>Thu, 09 Dec 2021 11:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20211209_nd_ce/1/</guid>
      <description>準備 ガウス分布 $$ p(x|\mu,\sigma)=\frac{1}{\sqrt{2\pi }}\exp{-\frac{(x-\mu)^2}{2\sigma^2}} $$ 期待値 $$\mathbb{E}[x]=\mu$$&#xA;分散 $$\mathbb{E}[x^2]=\mu^2+\sigma^2$$ $$\mathbb{V}[x]=\mathbb{E}[x^2]-(\mathbb{E}[x]^2)$$&#xA;導出 $$-\int_x p_1(x|\mu_1,\sigma_1)\log p_2(x|\mu_2,\sigma_2)dx$$&#xA;$$=-\mathbb{E}_{p1}[\log(\frac{1}{\sigma_2 \sqrt{2\pi}}\exp{-\frac{1}{2}(\frac{x-\mu_2}{\sigma_2})^2})]$$&#xA;$$=-\mathbb{E}_{p1}[-\log\sigma_2\sqrt{2\pi}-\frac{1}{2}(\frac{x-\mu_2}{\sigma_2})^2]$$&#xA;$$=\log\sigma_2\sqrt{2\pi}+\frac{1}{2}\mathbb{E}_{p1}(x-\mu_2)^2$$&#xA;$$=\log\sigma_2\sqrt{2\pi}+\frac{1}{2\sigma_2^2}( \mathbb{E}[x^2]-2\mu_2\mathbb{E}[x]+\mathbb{E}[\mu_2^2])$$&#xA;$$=\log\sigma_2\sqrt{2\pi}+\frac{1}{2\sigma_2^2}( \sigma_1^2+\mu_1^2-2\mu_1\mu_2+\mu_2^2)$$&#xA;$$=\log\sigma_2\sqrt{2\pi}+\frac{(\mu_1-\mu_2)^2+\sigma_1^2}{2\sigma_2^2}$$</description>
    </item>
    <item>
      <title>SQLの条件式</title>
      <link>https://yuhi-sa.github.io/posts/20211121_db/4-2/</link>
      <pubDate>Thu, 09 Dec 2021 10:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20211121_db/4-2/</guid>
      <description>条件式 CASE：条件分岐 CASE WHEN 条件1 THEN 値 WHEN 条件2 THEN 値 … ELSE 値 END GROUP BY：特定の値をグループ化 GROUP BY 対象列 HAVING：グループ化した後のデータを条件分岐 HAVING 条件式 </description>
    </item>
    <item>
      <title>SQLの関数</title>
      <link>https://yuhi-sa.github.io/posts/20211121_db/4/</link>
      <pubDate>Wed, 08 Dec 2021 10:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20211121_db/4/</guid>
      <description>文字列 文字列を大文字に変換 UPPER(文字列) 文字列を小文字に変換 LOWER(文字列) 開始位置から長さ分，文字列から抽出 SUBSTRING(文字列,開始位置,長さ) 対象文字列から検索文字列が最初に出現する位置を返却 INSTR(対象文字列，検索文字列) 文字列の長さを返却 LENGTH(文字列) 文字列1と文字列2を結合 CONCAT(文字列1, 文字列2) 文字数に達するまで文字列の右側に追加文字を追加 RPAD(文字列, 文字数, 追加文字) 文字列の先頭と末尾から文字Aを取り除く TRIM(文字A FROM 文字列) 文字列に含まれる文字Aを文字Bに変換 REPLACE(文字列, 文字A, 文字B) 時間 現在の日時を返却 NOW() 現在の日時を返却 CURDATE() 現在の時刻を返却 CURTIME() 日付Bから日付Aまでの日数 DATEDIFF(日付A, 日付B) 日付Aからn日後の日付を返却 DATE_ADD(日付A, INTERVAL n DAY) 日付Aの月の月末日付を返却 LAST_DAY(日付A) 数字 数値の小数点n以下を四捨五入 ROUND(数値, n) 数値の小数点n以下を切り捨て TRUNCATE(数値, n) 数値1を数値2で割った余りを返却 MOD(数値1, 数値2) </description>
    </item>
    <item>
      <title>公開鍵認証方式を用いたSSH通信の設定方法</title>
      <link>https://yuhi-sa.github.io/posts/20211121_linux/5/</link>
      <pubDate>Fri, 03 Dec 2021 10:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20211121_linux/5/</guid>
      <description>1. 暗号化方式の変更[接続先PC] 「/etc/ssh/sshd_config」を編集 $ sudo vi /etc/ssh/sshd/sshd_config 公開鍵暗号方式の有効化とパスワード認証方式の無効化 + PubkeyAuthentication yes # 追記 - PasswordAuthentication yes + PasswordAuthentication no # 変更 リスタート $ sudo systemctl restart sshd 2. 秘密鍵と公開鍵を作成[接続元PC] 鍵の作成 $ ssh-keygen -t rsa Generating public/private rsa key pair. Enter file in which to save the key (/Users/yuhi-sa/.ssh/id_rsa): # 無記入でEnter Enter passphrase (empty for no passphrase): # パスフレーズを入力 Enter same passphrase again: # パスフレーズを入力 Your identification has been saved in 保存先ディレクトリ Your public key has been saved in 保存名 ファイル名を空白にした場合は「/.</description>
    </item>
    <item>
      <title>SQLによるDBの検索</title>
      <link>https://yuhi-sa.github.io/posts/20211121_db/3/</link>
      <pubDate>Thu, 02 Dec 2021 10:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20211121_db/3/</guid>
      <description>基本構文 SELECT：データの検索を行う． SELECT 列リスト FROM 表名; DESCRIBE：方の構造を確認 DESCRIBE 表名; DISTINCT：重複データの排除 SELECT DISTINCT 列リスト FROM 表名; WHERE：検索条件を指定 SELECT 列リスト FROM 表名 WHERE 検索条件; ORDER BY：行のソート SELECT 列リスト FROM 表名 WHERE 検索条件 ORDER BY 条件 [ASC|DESC]; ASC：昇順 DESC：降順 検索条件の演算子 BETWEEN：データの範囲を指定&#xA;SELECT 列リスト FROM 表名 WHERE 列名 BETWEEN A AND B; IN：データと等しいかどうかの指定&#xA;SELECT 列リスト FROM 表名 WHERE 列名 IN (A, B, C); LIKE：データの一部と等しいかどうか指定&#xA;SELECT 列リスト FROM 表名 WHERE 列名 LIKE &amp;#34;A%&amp;#34;; ワイルドカード&#xA;%：0文字以上の任意文字列 _：任意の1文字 ISNULL：NULL値のデータを指定</description>
    </item>
    <item>
      <title>ネットワークのトラブルシューティングで利用する代表的なコマンド</title>
      <link>https://yuhi-sa.github.io/posts/20211121_linux/4/</link>
      <pubDate>Tue, 30 Nov 2021 10:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20211121_linux/4/</guid>
      <description>トラブルシューティング 一般的に下位のレイヤから確認を行う．&#xA;物理的な確認 IPアドレスの設定確認 ネットワーク経路確認 開いているポートの確認 代表的なコマンド ping 宛先へのネットワークの疎通確認&#xA;$ ping [オプション] 宛先IP オプション&#xA;-c　送信回数：送信回数指定 -i　送信間隔：送信間隔指定 -n：名前解決を行わない telnet アプリケーション層での疎通確認&#xA;$ telnet [オプション] 宛先IP [ポート番号] オプション&#xA;-l ユーザ名：ユーザ名指定 traceroute 始点から終点までのホスト間の経路情報確認&#xA;$ traceroute [オプション] 宛先IP オプション&#xA;-i インタフェース名：インタフェース名指定 -T：TCPプロトコル利用 -I：ICMPプロトコル利用 -n：名前解決を行わない ip route ルーティングテーブルのエントリ情報の表示&#xA;$ ip route [サブコマンド] サブコマンド&#xA;show：ルーティングテーブルの情報表示 add ネットワーク：ルーティングテーブルにエントリ追加 del ネットワーク：ルーティングテーブルからエントリ削除 ss ネットワーク接続の統計情報の出力(socket statistics)&#xA;$ ss [オプション] オプション&#xA;-a：すべて表示 -l：Listenポートのみ表示 -n：名前解決を行わない -t：TCPを表示 -u：UDPを表示 tcpdump ネットワーク上を流れる通信パケットの閲覧&#xA;$ tcpdump [オプション] [条件] オプション</description>
    </item>
    <item>
      <title>正規化</title>
      <link>https://yuhi-sa.github.io/posts/20211121_db/2/</link>
      <pubDate>Fri, 26 Nov 2021 10:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20211121_db/2/</guid>
      <description>正規化の目的 データの整合性の保持 データの冗長性の排除 データ操作の適正化 関数従属性について 完全関数従属性 主キーの全ての項目を使って値が決定する関係&#xA;部分関数従属性 主キーの一部の項目を使って値が決定する関係&#xA;推移関数従属性 主キー以外の項目に従属する関係&#xA;第一正規形 非正規形から，繰り返し部分を排除した形&#xA;更新方法 非正規表に主キーを設定 繰り返し部分を分離 分離した表に主キーを設定 第二正規形 第一正規形から，部分関数従属している項目を取り除いた形&#xA;更新方法 主キーが複合キーの表を探す 部分関数従属している項目を別の表として分離 元の表に分離した表の主キーを残す 第三正規形 第二正規形から，主キーに推移関数従属している項目を取り除いた形&#xA;更新方法 主キー以外の項目で，関数従属している項目を探す 主キー以外の項目で関数従属している項目を別の表として分離 元の表に分離した表の主キーを残す </description>
    </item>
    <item>
      <title>ネットワークの基礎</title>
      <link>https://yuhi-sa.github.io/posts/20211121_linux/3/</link>
      <pubDate>Mon, 22 Nov 2021 10:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20211121_linux/3/</guid>
      <description>TCP/IP TCP/IPはネットワークのプロトコルであり，４階層のプロトコルスタック(上からアプリケーション層，トランスポート層，インターネット層，ネットワークインターフェース層)で構成される． 中核となるプロトコルからTCP/IPと呼ばれる．&#xA;アプリケーション層 データを送受信する際の表現形式(文字コード，画像形式)の処理を実行&#xA;HTTP SMTP トランスポート層 通信するプログラム間でのデータ伝送確立の処理を実行&#xA;TCP UDP インターネット層 ネットワーク上のデータ送信先を検出，送信先までのルート計算処理を実行&#xA;IP ICMP ネットワークインタフェース層 インターネット層から受け取ったデータを電気信号に変換，ネットワーク媒体に送り出すための処理を実行&#xA;コネクション型とコネクションレス型 受信側がデータを受信したことを送信側に知らせる確認応答を行う通信をコネクション型，行わない通信をコネクションレス型とよぶ． 前者は，メールやWeb通信，後者は動画配信などに適している．&#xA;通信方式 ユニキャスト：1対1での通信 ブロードキャスト：同一ネットワーク内の全ホストに対してデータを送信 マルチキャスト：不特定多数のホストに対してデータを送信(同じIPアドレスが登録されたホストにデータを送信) エニーキャスト：不特定多数のホストに対してデータを送信(同じIPアドレスが登録されたホストのうち最も近いホストにデータを送信) グローバルアドレスとプライベートアドレス グローバルアドレスは，日本ネットワークインフォメーションセンター(JPNIC)から割り当てられるインターネットを使用するためのIPアドレスであり，一意の値が割り当てられる．プライベートアドレスは組織内のローカルネットワーク内でのみ使用可能なIPアドレス．&#xA;グローバルIPアドレスは国際機関IANA(Internet Assigned Numbers Authority)が管理している．IANAの配下に地域別の管理機関があり日本ではJPNIC(Japan Network Information Center)が日本国内のグローバルIPアドレスを管理している． JPNICはISP(プロバイダ)の要求に応じてIPアドレスを配布する．&#xA;ポート ネットワークアプリケーションを区別する際に使用される． 0から1023までは標準化されており，ウェルノウンポートまたは特権ポートとよぶ．代表的なポートは以下の通り．&#xA;20：FTP(データ転送) 21：FTP(制御情報) 22：SSH 25：SMTP 53：DNS 80：HTTP 110：POP3 143：IMAP 443：HTTPS </description>
    </item>
    <item>
      <title>SQLの基本構文</title>
      <link>https://yuhi-sa.github.io/posts/20211121_db/1/</link>
      <pubDate>Sun, 21 Nov 2021 10:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20211121_db/1/</guid>
      <description>データ操作 SELECT：レコードの検索，検索結果の結合 INSERT：レコードの挿入 UPDATE：レコードの更新 DELETE：レコードの削除 データ定義 CREATE：オブジェクトの定義 ALTER：オブジェクトの変更 DROP：オブジェクトの削除 RENAME：オブジェクト名の変更 TRUNCATE：データの切り捨て データ制御 COMMIT：トランザクションの確定 ROLLBACK：トランザクションの取り消し SAVEPOINT：ロールバック地点の設定 GRANT：権限の付与 REVOKE：権限の剥奪 </description>
    </item>
    <item>
      <title>スーパーユーザ</title>
      <link>https://yuhi-sa.github.io/posts/20211121_linux/1/</link>
      <pubDate>Sun, 21 Nov 2021 10:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20211121_linux/1/</guid>
      <description>ユーザーアカウントの種類 スーパーユーザ：全ての管理権限を有しているユーザ 一般ユーザ：限られた権限のみ付与されたユーザ システムユーザ：特殊なアプリケーション実行時のみに使用されるユーザ コマンド su：現在のユーザから別のユーザに切り替え $ su - [ユーザ名] sudo：一般ユーザの権限では実行できないコマンドを，一般ユーザでも実行できるように許可を与える $ sudo [オプション] [コマンド] 権限の設定 「/etc/sudoers」ファイルにユーザごとみ実行可能なコマンドが記載されており，「visudo」で編集することができる．&#xA;$ sudo visudo </description>
    </item>
    <item>
      <title>ユーザアカウント</title>
      <link>https://yuhi-sa.github.io/posts/20211121_linux/2/</link>
      <pubDate>Sun, 21 Nov 2021 10:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20211121_linux/2/</guid>
      <description>ユーザアカウント情報 ユーザアカウント情報は「/etc/passwd」ファイルに保存されている．1行ごとに1ユーザの情報が：で区切られた7つのフィールドで構成されている．&#xA;[ユーザ名]:[パスワード]:[ユーザID]:[グループID]:[コメント]:[ホームディレクトリ]:[ログインシェル] ここでパスワードはxと表示され，シャドウパスワードが用いられている．シャドウパスワードは「etc/shadow」ファイルに保存されており，rootユーザのみ読み取り専用として開くことができる．&#xA;ユーザ情報の編集コマンド useradd：一般ユーザの追加 usermod：ユーザ情報の変更 userdel：ユーザの削除 passwd：パスワードの変更 グループアカウント情報 グループアカウント情報は「/etc/group」ファイルに保存されている．1行ごとに1グループの情報が：で区切られた4つのフィールドで構成されている．&#xA;[グループ名]:[パスワード]:[グループID]:[メンバー] グループ情報の編集コマンド groupadd：グループの追加 groupmod：グループの変更 groupdel：グループの削除 id：所属するグループの確認 </description>
    </item>
    <item>
      <title>オブジェクト指向</title>
      <link>https://yuhi-sa.github.io/posts/20211112_java/1/</link>
      <pubDate>Fri, 12 Nov 2021 10:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20211112_java/1/</guid>
      <description>オブジェクトの構成要素 フィールド：オブジェクトがもつデータ メソット：オブジェクトがする処理 フィールドとメソットを合わせてメンバと呼ぶ&#xA;インスタンス化 オブジェクトの雛形を「クラス」，実際に使われる部品を「インスタンス」とよび，クラスをもとにインスタンスを作ることをインスタンス化とよぶ．&#xA;カプセル化 メンバに対するアクセス権を設定することにより，オブジェクトを安全で簡単に利用する方法．以下の二つの作業により実装．&#xA;データの隠蔽：フィールドへの直接悪説を禁止する フィールド操作用のメソッドの公開 継承 既存のクラスを利用して新しいクラスを定義すること．&#xA;ポリモフィズム 同一のクラスを継承しているサブクラスのメソッドの動作は同じとなるが，ポリモフィズムを用いると同じメソットの呼び出しに対し，インスタンスごとに異なった処理を実行できる．&#xA;UML(Unified Modeling Language) システム開発のさまざまな場面で使用する図を標準化した規格&#xA;クラス図 シーケンス図 ユースケース図 アクティビティ図 コンポーネント図 </description>
    </item>
    <item>
      <title>強化学習を用いてop3に歩行獲得させるROSパッケージのコード説明</title>
      <link>https://yuhi-sa.github.io/posts/20211102_op3/1/</link>
      <pubDate>Tue, 02 Nov 2021 10:17:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20211102_op3/1/</guid>
      <description>はじめに ROBOTIS OP3にGazeboシミュレーション内で強化学習を用いて歩行獲得させるROSパッケージのコード説明の記事です．&#xA;op3_walk 結果の動画 op3_controller_demo 手法の説明 深層強化学習(DQN)を使用しています．&#xA;行動価値関数は，3層のニューラルネットワーク(NN)として定義しQ値を以下のように更新し，&#xA;$Q(s_t,a_t) = Q(s_t,a_t) + \eta(R_{t+1)} + \gamma \max_a Q(s_{t+1},a) - Q(s_t,a_t)$&#xA;損失関数$L$を用いて誤差逆伝播しニューラルネットを更新しています．&#xA;$ L = \mathbb{E}(R_{t+1} + \gamma \max Q(s_{t+1},a_t)- Q(s_t,a_t))$&#xA;プログラムの説明 function.py and motion.py [function]にはエージェントの定義を書いています．&#xA;Agentクラスが，ニューラルネットの定義をしているBrainクラスを持っています．ReplayMemoryクラスに蓄積される行動と状態で，Brainは損失の計算と更新を行います．行動は離散化しており，[motion]で定義されている行動の中から，epsilon-greedy選択を行います．&#xA;こちらの書籍のコードを参考にしています．&#xA;Deep-Reinforcement-Learning-Book learning.py [learning]では，[function]で定義したAgentクラスを継承します．Agentに，[controller]からsubscribeした状態を入力，行動を計算し，publishします．こちらはニューラルネットワークの定義にpytorchを使っているため，python3系で実行する必要があります．&#xA;controller.py [controller]は．[learning]からpublishされた行動をsubscribeして，実際にop3を動かします．そして，状態をpublishします．こちらはop3のパッケージの関係で，python2系で実行する必要があります．&#xA;学習曲線 歩行距離の学習曲線 </description>
    </item>
    <item>
      <title>Apple純正デバイスへのgoogleカレンダーの他のカレンダー同期をする方法</title>
      <link>https://yuhi-sa.github.io/posts/20210912_google_cal_sync/1/</link>
      <pubDate>Sun, 12 Sep 2021 10:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20210912_google_cal_sync/1/</guid>
      <description>以下のリンクでチェックを入れる．&#xA;https://calendar.google.com/calendar/u/0/syncselect </description>
    </item>
    <item>
      <title>githubへのssh接続</title>
      <link>https://yuhi-sa.github.io/posts/20210818_github_ssh/1/</link>
      <pubDate>Wed, 18 Aug 2021 10:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20210818_github_ssh/1/</guid>
      <description>公開鍵・秘密鍵の生成 $ ssh-keygen -t ed25519 -C &amp;#34;メールアドレス&amp;#34; or $ ssh-keygen -t rsa -b 4096 -C &amp;#34;メールアドレス&amp;#34; Enterを押す．&#xA;&amp;gt; Enter a file in which to save the key (/Users/you/.ssh/id_ed25519): [Press enter] パスワードを設定&#xA;&amp;gt; Enter passphrase (empty for no passphrase): [Type a passphrase] &amp;gt; Enter same passphrase again: [Type passphrase again] 公開鍵をコピー&#xA;$ pbcopy &amp;lt; ~/.ssh/id_ed25519.pub or $ pbcopy &amp;lt; ~/.ssh/id_rsa.pub githubに公開鍵を登録する． ユーザ設定のサイドバーでSSH and GPG keys（SSH及びGPGキー）を選択． [Add SSH key]を選択し，コピーした公開鍵を貼り付け．(Titleは利用しているPCを識別できる名前) 接続テスト ssh -T git@github.</description>
    </item>
    <item>
      <title>Raspberry PiでAirplayをする方法メモ(RPiPlay)</title>
      <link>https://yuhi-sa.github.io/posts/20210805_rpiplay/1/</link>
      <pubDate>Thu, 05 Aug 2021 10:11:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20210805_rpiplay/1/</guid>
      <description>Raspberrypiを更新 パッケージの更新 sudo apt-get update sudo apt-get upgrade OSのアップデート sudo apt-get install rpi-update sudo rpi-update sudo reboot RPiPlayの設定 以下のコードを使う．&#xA;https://github.com/FD-/RPiPlay 必要なパッケージのインストール sudo apt-get install cmake sudo apt-get install libavahi-compat-libdnssd-dev sudo apt-get install libssl-dev sudo apt-get install libplist-dev 他の人のやり方だと最後の行なかったけど，自分の環境だと必要だった，&#xA;環境 PRETTY_NAME=&amp;#34;Raspbian GNU/Linux 10 (buster)&amp;#34; NAME=&amp;#34;Raspbian GNU/Linux&amp;#34; VERSION_ID=&amp;#34;10&amp;#34; VERSION=&amp;#34;10 (buster)&amp;#34; VERSION_CODENAME=buster ID=raspbian ID_LIKE=debian HOME_URL=&amp;#34;http://www.raspbian.org/&amp;#34; SUPPORT_URL=&amp;#34;http://www.raspbian.org/RaspbianForums&amp;#34; BUG_REPORT_URL=&amp;#34;http://www.raspbian.org/RaspbianBugs&amp;#34; RPiPlayのインストール git clone https://github.com/FD-/RPiPlay.git cd RPiPlay ビルド mkdir build cd build cmake .. make buildディレクトリにrpiplayという実行ファイルが作られる．&#xA;起動 .</description>
    </item>
    <item>
      <title>適応フィルタ</title>
      <link>https://yuhi-sa.github.io/posts/20210730_filter/1/</link>
      <pubDate>Fri, 30 Jul 2021 10:17:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20210730_filter/1/</guid>
      <description>デジタルフィルタ 信号をあるサンプリング周期でサンプリングした時系列信号$x_0,x_1,&amp;hellip;,x_N$に対する処理をデジタルフィルタとよぶ．代表的なデジタルフィルタに線形フィルタがある．&#xA;線形フィルタ FIR(有限インパルス応答)フィルタ $$y_k=w_0x_k+w_1x_{k-1}+&amp;hellip;+w_Nx_{k-N}$$ $w$がフィルタ係数&#xA;IIR(無限インパルス応答)フィルタ $$y_k=w_0x_k+w_1x_{k-1}+&amp;hellip;+w_Nx_{k-N}-v_1y_{k-1}-&amp;hellip;-v_My_{k-M}$$&#xA;$w,v$がフィルタ係数&#xA;適応フィルタ デジタルフィルタを学習によって構成する手法に適応フィルタがある．適応フィルタでは，FIRフィルタとIIRフィルタに対して同じ考え方でフィルタ設計を行うことができる．&#xA;適応フィルタの入出力 入力：$x_k=x(kT,k=0,1,2,&amp;hellip;)$&#xA;出力：$y_k= w_0 x_k + w_1 x_{k-1}+\dots+w_{N-1}x_{k-N+1}$&#xA;誤差：$e_k = d_k-y_k$&#xA;フィルタ設計 目標値$d_k$に対して適応フィルタの出力$y_k$をできるだけ近づけるように，係数を決定することが，フィルタ設計である． $$W = [W_0,w_1,&amp;hellip;,w_{N-1}]^t$$&#xA;$$X_k = [x_k,x_{k-1},&amp;hellip;,x_{k-N+1}]^t$$&#xA;とおくとフィルタ誤差は以下のように表すことができる．&#xA;$$e_k=d_k-W^tX_k=d_k-X_k^tW$$&#xA;誤差の二乗規範$J_k$を最小化することを考える．($E$は期待値)&#xA;$$J_k \triangleq \frac{1}{2} E [e_k^2]$$&#xA;$$J_k =\frac{1}{2}(E[d_k^2]+W^tE[X_kX_k^t]W-2E[d_kX_k^t]W) =\frac{1}{2}(E[d_k^2]+W^tRW-2R_{dX}W)$$&#xA;$J_k$を$W_k$で微分した値を0とおく．&#xA;$$\frac{\delta J_k}{\delta W_k} = RW -R_{dX}=0$$&#xA;$J_k$を最小にする$W_k$を$W^o$とおく．&#xA;$$EW^o=R_{dX}$$&#xA;この関係式をWiener-Hopf方程式と呼び，$R$が逆行列を有する場合には以下のように最適値を求めることができる．&#xA;$$W^o = R^{-1}R_{dX}$$&#xA;フィルタ係数の逐次計算 逆行列の計算を行わないでWiener-Hopf法的式を満たす$W^o$を求める場合には，勾配を用いて逐次計算を行う．&#xA;$$\delta W= -\eta \frac{\delta J}{\delta W}=-\eta(RW(old)-R_{dX})$$&#xA;ここで$\eta$は学習率&#xA;参考 大松 繁, &amp;ldquo;信号処理ーデジタルフィルタ&amp;rdquo;</description>
    </item>
    <item>
      <title>リーダブルコード読んだメモ</title>
      <link>https://yuhi-sa.github.io/posts/20210713_readable/1/</link>
      <pubDate>Tue, 13 Jul 2021 10:17:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20210713_readable/1/</guid>
      <description>名前に情報を詰め込む 汎用的な単語ではなく，明確な単語を使う．&#xA;単語 代替案 get fetch, download size Height, NumNodes, MemoryBytes stop kill, pause send deliver, dispatch, announce, distribute, route find search, extract, locate, recover start lainch, create, begin, open make create, set up, build, generate, compose, add, new 抽象的な名前ではなく，具体的な名前&#xA;tmpは生存期間が短く，一時的な保管が最も大切な変数のみに使う． イテレータは安易にi, j, kとするのではなく，club_i,member_i,user_iのように名付ける． より直接的で，明確な表現にする． ServerCanStart → CanListenOnPort 接尾辞，接頭辞で情報を追加する．&#xA;delay → delay_secs size → size_mb limit → max_kbp angle → degree_cw html → html_utf8 名前の長さを決める．&#xA;FormatString → FormatStr ConvertToString → ToString 名前のフォーマットで情報を伝える．</description>
    </item>
    <item>
      <title>GitHub Actions の書き方</title>
      <link>https://yuhi-sa.github.io/posts/20210630_gtihub_action/1/</link>
      <pubDate>Wed, 30 Jun 2021 10:17:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20210630_gtihub_action/1/</guid>
      <description>GitHub Actions CI / CDで自動化することによりGitHubから直接コードをビルド、テスト、デプロイなどをすることができる機能である．&#xA;リポジトリ直下に以下のディレクトリを作成し，YAMLファイルで自動化内容を記入することで実行できる．&#xA;.github/workflows/{自由な名前}.yml YAMLファイルの構成 以下の形式で，YAMLファイルを作成する．&#xA;name: {このワークフローの名前} on: # pushされた時に実行(blanchも指定できる) push: branches: [ master ] # pullリクエストされた時に実行(blanchも指定できる) pull_request: branches: [ master ] # 時間指定 # https://docs.github.com/ja/actions/reference/events-that-trigger-workflows schedule: - cron: &amp;#39;45 10 * * *&amp;#39; jobs: build: # 実行環境を指定(macやwindowsも指定可) runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 # 実行するコマンド - name: {操作名} run: | {コマンド} </description>
    </item>
    <item>
      <title>Pythonのmatplotで三次元動画を作成するプログラム</title>
      <link>https://yuhi-sa.github.io/posts/20210630_py_plot/1/</link>
      <pubDate>Wed, 30 Jun 2021 10:17:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20210630_py_plot/1/</guid>
      <description>import numpy as np import matplotlib.pyplot as plt import seaborn as sns import math import matplotlib.animation as animation from mpl_toolkits.mplot3d import Axes3D def makeAnimetion(data): print(&amp;#34;make Flame&amp;#34;) fig = plt.figure() ax = fig.add_subplot(111, projection=&amp;#39;3d&amp;#39;) # label ax.set_xlabel(&amp;#39;time&amp;#39;) ax.set_ylabel(&amp;#39;x&amp;#39;) ax.set_zlabel(&amp;#39;y&amp;#39;) # dimention ax.set_ylim(-3,3) ax.set_zlim(-3,3) ims = [] for i in range(len(data)): bar = str(round(i*100/len(data))) + &amp;#34;%&amp;#34; print(&amp;#34;\r&amp;#34;+bar,end=&amp;#34;&amp;#34;) X,Y,Z = data[i] im = ax.plot(X,Y,Z, marker=&amp;#34;o&amp;#34;,color = &amp;#34;red&amp;#34;, linestyle=&amp;#39;None&amp;#39;) ims.append(im) print(&amp;#34;&amp;#34;) print(&amp;#34;make Animation&amp;#34;) ani = animation.</description>
    </item>
    <item>
      <title>モーメント</title>
      <link>https://yuhi-sa.github.io/posts/20210527_moment/1/</link>
      <pubDate>Thu, 27 May 2021 10:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20210527_moment/1/</guid>
      <description>モーメントとは，ある点を中心として運動を起こす能力の大きさを表す物理量である．&#xA;モーメントの求め方 関数$f(x)$のモーメント&#xA;$$\mu_n = \int_\infty^\infty x^nf(x)dx$$&#xA;関数$f(x)$の$c$周りのモーメント&#xA;$$\mu_n^c = \int_\infty^\infty (x-c)^nf(x)dx$$&#xA;意味(n&amp;lt;3) $$\mu_0 = 1$$&#xA;$n=1$の時，平均値となる．&#xA;$$\mu_1 = \mu$$&#xA;$n=2$の時，分散となる．&#xA;$$\mu_2 = \sigma^2$$&#xA;意味(n&amp;gt;=3) $n=3$を用いて歪度(わいど)$\gamma_1$が表される． 歪度は分布が正規分布からどれだけ歪んでいるかを表す統計量である． $$\gamma_1 = \mu_3/\sigma^3$$&#xA;$n=4$を用いて尖度$\gamma_2$が表される． 尖度は分布が正規分布からどれだけ尖っているかを表す統計量 $$\gamma_2=\mu_4/\sigma^4 -3$$</description>
    </item>
    <item>
      <title>MacのLaunchpadを初期化する方法</title>
      <link>https://yuhi-sa.github.io/posts/20210520_mac_tips/1/</link>
      <pubDate>Tue, 20 Apr 2021 10:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20210520_mac_tips/1/</guid>
      <description>以下のコマンドですべて初期化される&#xA;defaults write com.apple.dock ResetLaunchPad -bool true; killall Dock </description>
    </item>
    <item>
      <title>PyenvとAnacondaを用いたPython環境の設定</title>
      <link>https://yuhi-sa.github.io/posts/20210416_py_env/1/</link>
      <pubDate>Fri, 16 Apr 2021 10:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20210416_py_env/1/</guid>
      <description>1. Homebrewのインストール Homebrewとは macOSオペレーティングシステム上のパッケージ管理システム．&#xA;インストール方法&#xA;ターミナルを開く 下記スクリプトをターミナルで実行 $ /bin/bash -c &amp;#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&amp;#34; インストールが進み，[Installation Success]と表示されたらインストール完了． 使い方&#xA;brew update: 更新&#xA;brew upgrade: 更新を実行&#xA;brew list: インストール済みのパッケージを見る&#xA;brew install [パッケージ名]: インストール&#xA;brew uninstall [パッケージ名]: アンインストール&#xA;brew info [パッケージ名]: 情報を見る&#xA;2. pyenvのインストール pyenvとは Pythonの複数のバージョンを使い分けるコマンドラインツール． インストール方法 Homebrewでpyenvをインストールする． brew install pyenv pathを通す $ echo &amp;#39;export PYENV_ROOT=&amp;#34;$HOME/.pyenv&amp;#34;&amp;#39; &amp;gt;&amp;gt; ~/.bash_profile $ echo &amp;#39;export PATH=&amp;#34;$PYENV_ROOT/bin:$PATH&amp;#34;&amp;#39; &amp;gt;&amp;gt; ~/.bash_profile $ echo &amp;#39;eval &amp;#34;$(pyenv init -)&amp;#34;&amp;#39; &amp;gt;&amp;gt; ~/.bash_profile パスを通す：実行ファイルの場所を教えること． echo： 「echo 文字 &amp;raquo; テキストファイル」で，テキストファイルに文字を追記するコマンド． bash_profile：ターミナル実行時に自動的に読まれるスクリプトが記述されている環境設定ファイル． 3.</description>
    </item>
    <item>
      <title>pythonでprintの上書きをする方法</title>
      <link>https://yuhi-sa.github.io/posts/20210514_py_print/1/</link>
      <pubDate>Fri, 16 Apr 2021 10:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20210514_py_print/1/</guid>
      <description>一行上書きする場合 print(&amp;#34;\r&amp;#34;+&amp;#34;一行上書きするよ！&amp;#34;,end=&amp;#34;&amp;#34;) n行上書きする場合 print(&amp;#34;n行上書きするよ！&amp;#34;+&amp;#34;\033[nA&amp;#34;) </description>
    </item>
    <item>
      <title>UbuntuでローカルDNSサーバーが指定できないときの編集方法</title>
      <link>https://yuhi-sa.github.io/posts/20210409_ubuntu_ssh/1/</link>
      <pubDate>Fri, 09 Apr 2021 10:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20210409_ubuntu_ssh/1/</guid>
      <description>/etc/resolv.conf を編集する．&#xA;# This file is managed by man:systemd-resolved(8). Do not edit. # # This is a dynamic resolv.conf file for connecting local clients to the # internal DNS stub resolver of systemd-resolved. This file lists all # configured search domains. # # Run &amp;#34;resolvectl status&amp;#34; to see details about the uplink DNS servers # currently in use. # # Third party programs must not access this file directly, but only through the # symlink at /etc/resolv.</description>
    </item>
    <item>
      <title>Ubuntuのsshの設定</title>
      <link>https://yuhi-sa.github.io/posts/20210409_ubuntu_ssh/2/</link>
      <pubDate>Fri, 09 Apr 2021 10:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20210409_ubuntu_ssh/2/</guid>
      <description>sshの設定 $ sudo apt-get install aptitude $ sudo aptitude install ssh /etc/ssh/sshd_configを編集&#xA;PermitRootLogin no $ sudo /etc/init.d/ssh restart warningが発生した場合 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! @ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ となった場合&#xA;ssh-keygen -R ipアドレス で鍵情報を消す．</description>
    </item>
    <item>
      <title>H無限大制御</title>
      <link>https://yuhi-sa.github.io/posts/20210405_hinf/1/</link>
      <pubDate>Mon, 05 Apr 2021 13:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20210405_hinf/1/</guid>
      <description>$H_\infty$制御問題の目的は，外乱$w$から出力$z$への閉ループ伝達関数$T_{zw}$の$H_\infty$ノルムを最小にしながら，誤差$z$をゼロにする制御器$K$を設計することである．&#xA;$$||T_{zw}||_\infty = \sup_w\frac{||z||_2}{||w||_2}$$&#xA;上式とスモールゲイン定理より，$H_\infty$制御は以下の式を満たす制御器を設計する問題となる．&#xA;$$||T_{zw}||_\infty^2 = \sup_w\frac{{||z||_2}^2}{{||w||_2}^2}$$&#xA;ここで，&#xA;$${||z||_2}^2=\int_0^\infty z^T(t)z(t)dt$$&#xA;$${||w||_2}^2=\int_0^\infty w^T(t)w(t)dt$$&#xA;よって，以下の式で定式化される．&#xA;$$V=\int_0^\infty(z^T(t)z(t)-\gamma^2w^Tw(t))dt \leq 0$$&#xA;$$V^\ast = \min_u\max_w[z^T(t)z(t)-\gamma^2w^T(t)w(t)]$$</description>
    </item>
    <item>
      <title>Pythonによる2進数変換と論理演算(or,xor)</title>
      <link>https://yuhi-sa.github.io/posts/20210329_bin/1/</link>
      <pubDate>Mon, 29 Mar 2021 12:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20210329_bin/1/</guid>
      <description>2進数変換 def binBin(num1,num2): binNum1 = list(bin(num1)) binNum1.pop(0) binNum1.pop(0) binNum2 = list(bin(num2)) binNum2.pop(0) binNum2.pop(0) while(len(binNum1) != len(binNum2)): if len(binNum1) &amp;lt; len(binNum2): binNum1.insert(0,0) elif len(binNum2) &amp;lt; len(binNum1): binNum1.insert(0,0) return binNum1, binNum2 10進数変換 def binNum(binNum): Num = 0 for i in range(len(binNum)): if int(binNum[len(binNum)-i-1]) == 1: Num += pow(2,i) return Num or計算 def orCal(num1,num2): binNum1, binNum2 = binBin(num1,num2) orValue = [] for i in range(len(binNum1)): if int(binNum1[i]) == 1 or int(binNum2[i]) == 1: orValue.</description>
    </item>
    <item>
      <title>クロスエントロピー法(Cross Entropy Method)</title>
      <link>https://yuhi-sa.github.io/posts/20210329_cem/1/</link>
      <pubDate>Mon, 29 Mar 2021 11:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20210329_cem/1/</guid>
      <description>クロスエントロピー法は，モンテカルロ法における重点サンプリング法の一種であり、最適化問題において確率分布の近似を行うアルゴリズムである。&#xA;モンテカルロサンプリング モンテカルロ法は，乱数を用いる数値計算法の総称である．&#xA;問題設定として，$X$を確率変数，$H$を目的の関数，$f$を$H$の$X$における確率密度関数とした場合，期待値&#xA;$$l=\int H(x)f(x)dx = E[H(X)]$$&#xA;を知りたいとする． モンテカルロサンプリングでは，以下のようにこれを近似する．&#xA;$$l_{MS}=\frac{1}{N}\sum_{i=1}^{N}(X_i)$$&#xA;重点サンプリング(Importance Sampling) 重点サンプリングでは，モンテカルロサンプリングより効率よくサンプリングを行うために，分散の小さい分布からサンプリングすることを考える．&#xA;重点サンプリングでは，$g(x)=0$のとき$H(x)f(x)=0$となる，確率密度関数$g$を用意して以下のように推定量の近似を行う．&#xA;$$l_{IS}=\frac{1}{N}\sum_{i=1}^NH(X_i)\frac{f(X_i)}{g(X_i)}=E[H(X)\frac{f(X)}{g(X)}]$$&#xA;クロスエントロピー法 クロスエントロピー法では，重点サンプリングでの$g$の最適分布$g^*$と近い分布を用いることを考える．&#xA;ここで，確率分布間の距離を測る指標としてクロスエントロピーを用いる．クロスエントロピー$D$は，以下の式で表される．&#xA;$$D(g,h)=\int \log \frac{g(x)}{h(x)}g(x)dx$$&#xA;$D(g^\ast,h)$を最小にする$h$を求めれば，$g^\ast$に近い分布，つまり分散の小さい分布が獲得可能である．&#xA;$$l_{CEM}=E[H(X)\frac{f(X;u)}{g(X;v)}]$$&#xA;$$v^{\ast}=arg min_v D[g^{\ast},g(x;v)]$$&#xA;参考文献 漆原 勉,&amp;ldquo;モンテカルロシミュレーションにおける重点サンプリング法に対する大偏差理論の適用について&amp;rdquo; クロスエントロピー法 - Cross-coupling reactionWikipedia site:nipponkaigi.net </description>
    </item>
    <item>
      <title>DNNを利用した強化学習の仲間たち</title>
      <link>https://yuhi-sa.github.io/posts/20210319_rl/7/</link>
      <pubDate>Mon, 22 Mar 2021 11:35:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20210319_rl/7/</guid>
      <description>Actor Critic系 Asynchronous Advantage Actor Critic(A3C) A3CはA2Cと同様に分散環境を使用するが，各環境のエージェントはそこで経験を収集するだけでなく学習も行う．これがAsynchronousな学習である．&#xA;Asynchronousな学習をしなくても十分な精度が出るためA2Cが生まれた．&#xA;Experience Replyでは，大きなバッファを用意して多様性を担保にしていたが，ぶんさん収集では別々の環境における経験を集めることで多様性を担保する．&#xA;Deep Deterministic Policy Gradient(DDPG) Experience Replyを用いたActor-Criticの手法．行動を行動確率の分布からサンプリングするのではなく，行動を直接出力する，また，学習に関してはAdvantageではなく，TD誤差を用いる．&#xA;Deterministic Policy Gradient(DPG) 行動が確率的ではなく，価値ベースのようにベストな行動が決定的に選択されるという前提をおいた手法である．&#xA;方策勾配系 Trust Region Policy Optimization(TRPO) 方策勾配系の手法は実験結果が安定しない場合がある．この点を改善する手法がいくつか提案されている． その一つが，更新前の方策から大きく離れないように制約をかける方法である．&#xA;$$\mathbb{E}[KL[\pi_{\theta_{old}}(･|s_t),\pi_\theta(･|s_t)]] \leq \delta$$&#xA;更新前の行動分布$\pi_{\theta_{old}}(･|s_t)$と更新後の行動分布$\pi_\theta(･|s_t)$の分布間の距離KLダイバージェンスが$\delta$以下になるように制約をかけ，制約の下でAdvantageが大きくなるように更新する．&#xA;Advantageには更新の前後の変化に応じて重み($\frac{\pi_\theta(･|s_t)}{\pi_{\theta_{old}}(･|s_t)}$)がかけられる．&#xA;$$\max_\theta \mathbb{E}[\frac{\pi_\theta(･|s_t)}{\pi_{\theta_{old}}(･|s_t)}A_t]$$&#xA;TRPOにおける距離の制約は，目的関数の中に組み込むことが可能である．&#xA;$$r_t(\theta) = \mathbb{E}[\frac{\pi_\theta(･|s_t)}{\pi_{\theta_{old}}(･|s_t)}A_t - \beta KL[\pi_{\theta_{old}}(･|s_t),\pi_\theta(･|s_t)]]$$&#xA;Proximal Policy Optimization(PPO) TRPOの距離制約を含んだ目的関数$r_t(\theta)$において，更新前後の分布が前後完全に一致した場合1となる.&#xA;$r_t(\theta)$が1から大きく離れる場合，一定の上限値で制限する．以下の式では，$r_t(\theta)$を$1-\epsilon$から$1+\epsilon$の範囲に制限している．&#xA;$$clip(r_t(\theta),1-\epsilon,1+\epsilon)A_t$$&#xA;この制約を目的関数に組み込んだ手法がProximal Policy Optimization(PPO)である．&#xA;参考 久保隆宏,&amp;quot;Pythonで学ぶ強化学習 入門から実践まで&amp;quot;</description>
    </item>
    <item>
      <title>Advantage Actor Critic(A2C)</title>
      <link>https://yuhi-sa.github.io/posts/20210319_rl/6/</link>
      <pubDate>Mon, 22 Mar 2021 11:30:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20210319_rl/6/</guid>
      <description>状態における行動価値$Q(s,a)$は，状態そのものへの依存度が大きい傾向がある．そこで状態の価値$V(s)$を差し引いたうえで行動を評価することを考える．&#xA;$$A(s,a)=Q(s,a)-V(s)$$&#xA;この$A(s,a)$をAdvantageと呼ぶ． Advantageを利用する場合の方策勾配は以下のようになる．&#xA;$$\nabla J(\theta) = E_{\pi_{\theta}}[\nabla \log \pi_{\theta(a|s)}A(s,a)]$$&#xA;$\pi_\theta(a|s)$をActor，Advantageの計算に必要な$V(s)$をCriticとしてActor Critic法を使用することができる． これをAdvantage Actor Critic(A2C)と呼ぶ．&#xA;参考 久保隆宏,&amp;quot;Pythonで学ぶ強化学習 入門から実践まで&amp;quot;</description>
    </item>
    <item>
      <title>方策勾配法</title>
      <link>https://yuhi-sa.github.io/posts/20210319_rl/5/</link>
      <pubDate>Mon, 22 Mar 2021 11:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20210319_rl/5/</guid>
      <description>方策もパラメータをもつ関数として表現可能である．状態を引数にとり，行動確率を出力する関数である．&#xA;方策の価値を期待値で計算する．方策に従い状態に遷移する確率$d^{\pi_\theta}(s)$・行動確率$\pi_\theta(a|s)$・行動価値$Q^{\pi_\theta}(s,a)$から計算を行う．&#xA;$$J(\theta) \propto \sum_s d^{\pi_\theta}(s)\sum_a\pi_\theta(a|s)Q^{\pi_\theta}(s,a)$$&#xA;期待値の最大化を考えてパラメータの調整を行う．勾配法で方策の期待値の最適化を行う手法を方策勾配法とよぶ．&#xA;$$\nabla J(\theta) \propto \sum_s d^{\pi_\theta}(s)\sum_a \nabla \pi_\theta(a|s)Q^{\pi_\theta}(s,a)$$&#xA;$$\nabla\pi_\theta(a|s)=\pi_\theta(a|s)\frac{\nabla \pi_\theta(a|s)}{\pi_\theta (a|s)}=\pi_\theta(a|s)\nabla \log \pi_\theta(a|s)$$&#xA;以上より，&#xA;$$\nabla J(\theta) \propto E_{\pi_{\theta}}[\nabla\log\pi_{\theta(a|s)}Q^{\pi_{\theta}}(s,a)]$$&#xA;勾配である$\nabla \log \pi_\theta(a|s)$が移動方向，$Q^{\pi_\theta}(s,a)$が大きさというふうに解釈できる．&#xA;参考 久保隆宏,&amp;quot;Pythonで学ぶ強化学習 入門から実践まで&amp;quot;</description>
    </item>
    <item>
      <title>ニューラルネットを適応した強化学習</title>
      <link>https://yuhi-sa.github.io/posts/20210319_rl/4/</link>
      <pubDate>Mon, 22 Mar 2021 10:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20210319_rl/4/</guid>
      <description>学習安定化のための方法 Experience Replay 行動履歴をプールしておき，そこからサンプリングすることで，さまざまなエピソードにおける，異なるタイムステップのデータを学習データとして使用する．これにより学習する経験の偏りを防ぎ，学習を安定化させる．&#xA;Fixed Target Q-Network 一定期間固定されたパラメーターから価値を算出する手法．遷移先の価値を本体のモデルで計算する場合，学習のたびにパラメーターが変わるため，値が毎回変わることとなる．これではTD誤差が安定しないため，一定期間パラメーターを固定する．&#xA;報酬のClipping 全ゲームを通じ成功は1，失敗は-1と報酬を統一する．&#xA;Deep Q-Network(DQN)とその改良 価値評価に深層学習を適応する方法をDeep Q-Network(DQN)とよぶ．単純にニューラルネットを使用するだけでは学習が安定しないため，前項のような安定化の工夫が必要となる．&#xA;DQNを発表したDeep Mindは，改良手法6つを組み込んだRainbowというモデルを発表している．&#xA;Double DQN 行動価値と行動選択のネットワークを分けることで価値の見積もり精度を上げる．&#xA;Prioritized Replay Experience Replyから単純にランダムサンプリングするのではなく，学習効果の高い(TD誤差が大きいもの)を優先してサンプリングを行い学習効率を上げる．&#xA;Dueling Network 状態価値と行動価値を分けて計算することにより価値の見積もり精度を上げる．&#xA;Multi-step Learning Q学習とMonteCarlo法の間をとる手法で，「nステップ分の報酬」と「nステップ先の状態の価値」から修正を行うことで，価値の見積もり精度を上げる．&#xA;Distributional RL 報酬を分布として扱い，価値の見積もり精度を上げる．&#xA;Noisy Nets Epsilon-Greedy法においてEpsilonの設定は非常にセンシティブである．Noisy Netsではどのくらいランダムに行動したほうがよいか自体をネットワークに学習することで探索効率を上げる．&#xA;参考 久保隆宏,&amp;quot;Pythonで学ぶ強化学習 入門から実践まで&amp;quot;</description>
    </item>
    <item>
      <title>モデルフリー強化学習</title>
      <link>https://yuhi-sa.github.io/posts/20210319_rl/3/</link>
      <pubDate>Fri, 19 Mar 2021 12:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20210319_rl/3/</guid>
      <description>モデルフリーの強化学習では，モデル(遷移関数$T(s&amp;rsquo;|s,a)$・報酬関数$R(s,s&amp;rsquo;)$)が未知であることが前提で，エージェント自らが動くことで経験を蓄積し，その経験から学習を行う．&#xA;探索と活用のトレードオフ 無限に行動することが可能であれば十分な探索の後に経験をかつようすればよい．しかし，多くの場合行動回数に何かしらの制限がある． どれくらい調査の行動をして，どのくらい報酬目的の行動をするかを探索と活用のトレードオフとよぶ．トレードオフのバランスを取る手法として，Epsilon-Greedy法が一般的である．&#xA;Epsilon-Greedy法&#xA;Epsilonの確率で探索を行い，それ以外は活用目的の行動を行う． 計画の修正を実績で行うか，予測で行うか 計画の修正を実績に基づき行う場合と，予測により行う場合のトレードオフも存在する．&#xA;前者の手法としてモンテカルロ法，後者の手法としてTD法，両者の間をとる手法としてTD($\lambda$)法がある．&#xA;モンテカルロ法(時刻Tでエピソード修了) エピソードが修了した後に，獲得できた報酬の総和をもとに修正を行うシンプルな方法である．&#xA;$$V(s_t) \leftarrow V(s_t)+\alpha((r_{t+1}+\gamma r_{t+2} + \gamma^2 r_{t+3} + ,&amp;hellip;,\gamma^{T-1}r_T )-V(s_t))$$&#xA;1エピソードが終了する修正できない．&#xA;TD法 学習する経験は，見積もり$V(s)$と実際$r+V(s&amp;rsquo;)$の誤差である(TD誤差)．経験による修正は，以下のように価値の更新を行うこととなる．&#xA;$$V(s_t) \leftarrow V(s_t)+\alpha(r_{t+1}+\gamma V(s_{t+1})-V(s_t))$$&#xA;1stepごとに更新を行う手法がTD法となる． 修正期間を1より大きく，$T$より小さい値に設定する手法をMulti-step Learningとよぶ．&#xA;TD($\lambda$)法 各stepにおける実際の価値を係数$\lambda$を使い合算した結果から，誤差を計算する手法である．&#xA;1step：$G_t^1=r_{t+1}+\gamma V(s_{t+1})$ 2step：$G_t^2=r_{t+1}+\gamma r_{t+2}+\gamma^2 V(s_{t+2})$ $T$step：$G_t^T=r_{t+1}+\gamma r_{t+2}+,&amp;hellip;,+\gamma^{T-1}r_T$ $\lambda=1$でモンテカルロ法と等価なる．&#xA;価値ベースと方策ベース モデルベース強化学習と同様に経験を価値評価の更新に用いるか方策の更新に用いるかで2つに分かれる．行動価値を$Q$で表す．&#xA;価値ベース(Off-policy) Q-learning&#xA;$$Q(s_t) \leftarrow Q(s_t)+\alpha(r_{t+1}+\gamma \max_a Q(s_{t+1})-Q(s_t))$$ 方策ベース(On-policy) SARSA $$Q(s_t) \leftarrow Q(s_t)+\alpha(r_{t+1}+\gamma Q(s_{t+1})-Q(s_t))$$ Actor-Critic法 価値ベースと方策ベースを組み合わせた手法をActor-Critic法とよぶ．方策評価をActor，価値評価をCriticで相互に更新し学習を行う．&#xA;参考 久保隆宏,&amp;quot;Pythonで学ぶ強化学習 入門から実践まで&amp;quot;</description>
    </item>
    <item>
      <title>モデルベース強化学習</title>
      <link>https://yuhi-sa.github.io/posts/20210319_rl/2/</link>
      <pubDate>Thu, 18 Mar 2021 19:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20210319_rl/2/</guid>
      <description>強化学習は，価値評価と方策の学習が必要であり，モデルを利用するかどうかで2種類に別れます．&#xA;モデルベース強化学習：モデル(遷移関数$T(s&amp;rsquo;|s,a)$・報酬関数$R(s,s&amp;rsquo;)$)をベースに行動を学習する手法(遷移関数・報酬関数が既知でなくても推定して利用可) モデルフリー強化学習：モデル(遷移関数・報酬関数)を使わない学習 以下は，モデルベースについてまとめる．&#xA;価値の定義 価値の定義には2つの問題がある．&#xA;将来の即時報酬$G_{t}$の値が判明している必要がある点&#xA;→価値を再帰的な式に変換する&#xA;$G_t=r_{t+1}+\gamma G_{t+1}$ それが必ず得られるとしている点&#xA;→即時報酬に確率をかける(期待値計算と同義)&#xA;$V_\pi(s_t)=E_\pi[r_{t+1}+\gamma V_\pi(s_{t+1})]$ ベルマン方程式 価値を再帰的かつ期待値で表現した式をベルマン方程式とよぶ． $$V_\pi(s)=\sum_a\pi(a|s)\sum_{s&amp;rsquo;}T(s&amp;rsquo;|s,a)(R(s,s&amp;rsquo;)+\gamma V_\pi(s&amp;rsquo;))$$&#xA;学習 動的計画法の枠組みでの学習を考える．動的計画法では$V(s&amp;rsquo;)$に適当な値を設定しておき，複数回計算を繰り返すことで値の精度を上げる．&#xA;動的計画法による最適行動の獲得では，価値を直接行動決定に利用する価値ベース，価値を方策の評価に利用する方策ベースの2種類がある．&#xA;価値ベース エージェントは各状態の価値を算出し，値が最も高い状態に遷移するように行動する．&#xA;動的計画法により各状態の価値を算出する方法を価値反復法とよぶ． $$V_{t+1}(s)=\max_{a}{\sum_{s&amp;rsquo;}T(s&amp;rsquo;|s,a)(R(s)+\gamma V_t{s&amp;rsquo;})}$$&#xA;方策ベース エージェントは方策に基づき行動する．&#xA;方策は状態における行動確率を出力するが，この行動確率から価値の計算が可能になる． 方策により価値を計算し，価値を最大化するように方策を更新する．これを方策反復法とよぶ．&#xA;$$V_\pi(s)=\sum_a\pi(a|s)\sum_{s&amp;rsquo;}T(s&amp;rsquo;|s,a)(R(s,s&amp;rsquo;),\gamma V_\pi(s&amp;rsquo;))$$&#xA;モデルベースとモデルフリーの違い モデルベースの動的計画法において，エージェントは動かさないで環境の情報のみから方策を得ている．これが可能なのは，遷移関数と報酬関数が既知だからである． モデルフリーでは，実際にエージェントを動かしその経験から学習を行う．&#xA;参考 久保隆宏,&amp;quot;Pythonで学ぶ強化学習 入門から実践まで&amp;quot;</description>
    </item>
    <item>
      <title>強化学習とは</title>
      <link>https://yuhi-sa.github.io/posts/20210319_rl/1/</link>
      <pubDate>Thu, 18 Mar 2021 18:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20210319_rl/1/</guid>
      <description>機械学習の用語整理 モデルとよばれるパラメータを持った数式のパラメータを，与えられたデータに応じて調整することを学習と呼ぶ．&#xA;モデルの一種としてニューラルネットワーク(NN)があり，多層にしたものがディープニューラルネットワーク(DNN)となる． モデルのパラメータを調整する手法として教師あり学習，教師なし学習，強化学習がある．&#xA;機械学習&#xA;「機械」= モデル ニューラルネットワーク ディープニューラルネットワーク 「学習」(方法) 教師あり学習 教師なし学習 強化学習 強化学習とは 強化学習では，データを与えられる教師あり学習，教師なし学習とは異なり環境が与えられる．&#xA;環境：行動と行動に応じた状態が定義されており，ある状態への到達に対し報酬が与えられる空間のこと 強化学習では，環境で報酬が得られるようにモデルのパラメータを調整する．環境の開始から終了までの期間を1エピソードとよび，1エピソードで得られる報酬を最大化することが学習の目的となる．&#xA;問題設定 マルコフ性(遷移先の状態は直前の状態とそこでの行動のみに依存する)に従うマルコフ決定過程(MDP)を考える． MDPの構成要素は，以下の4つである．&#xA;$s$：状態 $a$：行動 $T$：状態遷移確率&#xA;状態と行動を引数に遷移先と遷移確率を出力する関数 $R$：報酬関数&#xA;状態と遷移先を引数に報酬を出力する関数 ここで，ロボット(エージェント)は状態を受け取り行動を出力する関数とみなすことができる．この関数のことを方策$\pi$とよび，報酬をもとに方策を更新していくことで最適な方策を発見する．&#xA;参考 久保隆宏,&amp;quot;Pythonで学ぶ強化学習 入門から実践まで&amp;quot;</description>
    </item>
    <item>
      <title>K-means法</title>
      <link>https://yuhi-sa.github.io/posts/20210318_pid/2/</link>
      <pubDate>Thu, 18 Mar 2021 16:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20210318_pid/2/</guid>
      <description>$K$-means法は非階層型クラスタリングの一種である．非階層クラスタリングとは、与えられたデータを決められたクラスタ数で分割し，各クラスタが互いに似た性質を持つ分割方法を探索する手法である．階層クラスタリングと異なり、階層的な構造を持たず、サンプル数が大きいビッグデータを分析するときに適している。&#xA;$K$-means法は与えられたデータとクラスタの中心との距離を測定して使ってデータを$K$個のクラスタに分割する手法である．$c_j$をクラスタ$C_j$の重心点，すなわち，クラスタ$C_j$内の粒子の平均$c_j=\sum_{x∈C_j}\frac{x}{|C_j|}$とし，以下の評価関数を最小化するように$K$個のクラスタに分割する．&#xA;$$c_i=\sum_{i=1}^K\sum_{x∈C_i}(x-c_j)^2$$&#xA;ランダムにデータ$X(x_i,x_2,&amp;hellip;,x_n)$を$K$個のクラスタに割り振る クラスタの重心点$c_j(j=1,2,&amp;hellip;,K)$を計算する データ$X(x_i,x_2,&amp;hellip;,x_n)$最も近いクラスタの重心点$c_j(j=1,2,&amp;hellip;,K)$にクラスタを割り当て直す． クラスタの重心点が移動しなくなるまで，もしくは既定回数になるまでStep2とStep3を繰り返す． </description>
    </item>
    <item>
      <title>PID制御</title>
      <link>https://yuhi-sa.github.io/posts/20210318_pid/1/</link>
      <pubDate>Thu, 18 Mar 2021 15:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20210318_pid/1/</guid>
      <description>PID制御とは あるシステムを制御の出力値$y(t)$を制御するために，制御対象の出力をコントローラにフィードバックさせて，その情報をもとに制御する手法がある(フィードバック制御)．フィードバック制御では，出力値$y(t)$と目標値$r(t)$との偏差$e(t)$に基づいて操作量の計算を行うことで，制御系の安定化，目標値への追従性の向上，外乱抑制が可能となる．&#xA;P制御 P制御の入力値$u(t)$は以下の式で与えられる．このとき，$e(t)=r(t)-y(t)$とする．&#xA;$$u(t)=K_Pe(t)$$&#xA;$K_p$を大きくすると，偏差は小さくなる．しかし，$K_p$を大きくすると，応答が振動的になり，最終的には制御が不安定となり発散してしまう．また，偏差が小さくなると，入力値が消失するため，定常偏差(定常状態での偏差)を完全になくすことはできない．&#xA;PI制御 PI制御の入力値$u(t)$は以下の式で与えられる．&#xA;$$ u(t)=K_Pe(t)+K_I\int_0^te(\tau)d\tau$$&#xA;I制御は，偏差の積分値をフィードバックするため，偏差が小さくなったとしても入力値が消失することはない．これにより，定常偏差を解消する．ただし，積分動作により位相が遅れてしまうため出力値が急激に変化した場合，オーバーシュートやハンチングが生じることがある．&#xA;PID制御 PID制御の入力値$u(t)$は以下の式で与えられる．&#xA;$$u(t)=K_Pe(t)+K_I\int_0^te(\tau)d\tau+K_D\frac{de(t)}{dt}$$&#xA;D制御は，偏差の微分値をフィードバックするため，出力値の急激な変化に対して早めに偏差の増減を抑制し，応答の遅れを改善することができる．&#xA;PID制御は，偏差のP「現在」，I「過去」，D「未来」に基づいて制御することにより，安定性，追従性，即応性を満足する制御系を構成することができる．PID制御では，$K_P$，$K_I$，$K_D$のパラメータを適切に決定することが求められる．</description>
    </item>
    <item>
      <title>変分オートエンコーダ(VAE)</title>
      <link>https://yuhi-sa.github.io/posts/20210317_bayes/13/</link>
      <pubDate>Thu, 18 Mar 2021 12:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20210317_bayes/13/</guid>
      <description>EMアルゴリズムでは，完全データの分布$p(z|x,\theta)$と不完全データの分布$p(z|x,\hat{\theta})$の関数系は同じであった． VAEでは，2つの分布の関数系が異なってもよいという一般化を行う． そのため以下の表記では，&#xA;$p(z|x,\hat{\theta})$を認識モデル(エンコーダ)$q_\Phi(z|x)$ $p(z|x,\theta)$を生成モデル(デコーダ)$p_\theta(x|z)$ とする． また，潜在変数$z$は観測値$x$の持つ情報を別の形で表現しているため符号(コード)とよぶ．&#xA;オートエンコーダ(自己符号化器) オートエンコーダは，入力と出力が一致するようにパラメータの学習を行う装置である．VAEは変分下界を使って訓練を行うオートエンコーダである．&#xA;入力と同じ内容を出力する装置では中間的な層において符号化が行われており，これは情報圧縮をしていることに相当する．&#xA;VAEにおける変分下界 EMアルゴリズムで使用した変分下界を$\theta$と$\phi$を用いて書き直す． EMアルゴリズムによる混合ガウスモデルの学習では$z$はone-hotベクトルとしたが，VAEでは連続値である．よって$z$は多変量正規分布に従うモデルを用いる．&#xA;認識モデル VAEでは認識モデル$q_\Phi(z|x)$として以下のように定義される多変量正規分布を用いる．&#xA;$$q_\Phi(z|x)=\Pi_{j=1}^k\mathcal{N}(z_j|\mu_j(x),\sigma^2(x))$$&#xA;$\mu_j,\sigma_j^2$としてニューラルネットワークを使用するのが一般的である．&#xA;生成モデル 生成モデル$p_\theta(x|z)$としてどのような確率分布が使われるかは$x$がどのような変数であるかに依存する．$x$がone-hot表現であればマルチヌーイ分布が使える．$x$が連続値ベクトルの場合，以下のように分散を1とする多変量正規分布が使える．&#xA;$$p_\theta(x|z)=\Pi_{h=1}^m \mathcal{N}(x_h|\nu_h(z),1)$$&#xA;符号の事前分布 標準正規分布の積を使用することが多い．&#xA;$$p_\theta(z)=\Pi_{j=1}^k\mathcal{N}(z_j|0,1)$$&#xA;勾配降下法 VAEの学習は変分下界が増加していくように，パラメータ$\theta$と$\phi$を変えていくことで行われる． 具体的には$\mathcal{B}(\theta,\phi)$の$\theta$と$\phi$での微分，すなわち勾配を求め，勾配方向にパラメータを少しづつ変える．&#xA;事前分布を上記のように定義した場合は，事前分布に$\theta$を使わないため，$\mathcal{D}(q_\phi(z|x)||p_\theta(z))$は$\theta$を含まない．そのため$\theta$による勾配は不要である．$\phi$による勾配は合成関数の微分を使うと以下のように展開される．&#xA;$$\nabla_\phi \mathcal{D}(q_\phi(z|x)||p_\theta(z))=\sum_{j=1}^k (\frac{d\mathcal{D}(q_\theta(z|x)||p_\theta(z))}{d\mu_j}\nabla_\theta \mu_j + \frac{d\mathcal{D}(q_\theta(z|x)||p_\theta(z))}{d\sigma_j^2}\nabla_\theta \sigma_j^2)$$&#xA;参考 手塚 太郎，&amp;quot;しくみがわかるベイズ統計と機械学習&amp;quot; </description>
    </item>
    <item>
      <title>マルコフ連鎖モンテカルロ法(MCMC)</title>
      <link>https://yuhi-sa.github.io/posts/20210317_bayes/12/</link>
      <pubDate>Thu, 18 Mar 2021 11:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20210317_bayes/12/</guid>
      <description>マルコフ性とマルコフ連鎖 時刻$t$が1,2,3という離散的な値であり，それぞれにそれぞれに$x^{(1)},x^{(2)},x^{(3)}$という確率変数を持つ系列を考える．&#xA;マルコフ連鎖：$x^{(1)},x^{(2)},x^{(3)}$の確率変数を決めていくシステム マルコフ性：現在の状態は，直近の状態によってのみ決まる． 1次マルコフ性:$x^{(t)}$の状態は$x^{(t-1)}$のみによって決まる． $n$次マルコフ性：$x^{(t)}$の状態は$x^{(t-1)},&amp;hellip;,x^{(t-n)}$のみによって決まる． 遷移確率$p(x^{(t)}|x^{(t-1)})$：時刻$t-1$の状態から時刻$t$の状態に遷移する確率 定常分布$\pi$：遷移前の状態を$x$,遷移後の状態を$y$として以下の性質(定常性)が成り立つ分布． $\pi(y)=\sum_x p(y|x)\pi(x)$ マルコフ連鎖モンテカルロ法(MCMC) MCMCでは遷移確率$p(y|x)$を使って，標本の系列$x^{(1)},x^{(2)},&amp;hellip;$を作成する．MCMCで作成される標本のうち，最初の方は初期値への依存性が強ういため，$t$を十分に大きな数として$x^{(t)}$以降を使用する． MCMCで広く使われている方法が，メトロポリス・ヘイスティングス法である．&#xA;メトロポリス・ヘイスティング法 $t=1$と設定し，$x^{(1)}$を初期分布$p_1(x)$からサンプリング後，以下を繰り返す．&#xA;提案分布$q(\hat{y}|x^{(t)}$に従って標本候補$\hat{y}$を得る．&#xA;確率$\alpha(x^{(t)},\hat{y})$で標本候補$\hat{y}$を標本候補$\hat{y}$を$x^{(t+1)}$として採択する．&#xA;$$\alpha(x^{(t)},\hat{y})=\min(\frac{q(x^{(t)}|\hat{y})b(\hat{y})}{q(\hat{y}|x^{(t)})b(x^{(t)})},1)$$&#xA;$t=t+1$&#xA;参考 手塚 太郎，&amp;quot;しくみがわかるベイズ統計と機械学習&amp;quot; </description>
    </item>
    <item>
      <title>変分ベイズ</title>
      <link>https://yuhi-sa.github.io/posts/20210317_bayes/11/</link>
      <pubDate>Thu, 18 Mar 2021 10:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20210317_bayes/11/</guid>
      <description>変分ベイズは，EMアルゴリズムと同様に変分下界を使いつつパラメータ分布も考えることでベイズ的な拡張も行う手法である． EMアルゴリズムではパラメータ$\theta$を引数とする変分下界$\mathcal{B}(\theta,\hat{\theta})$を考えたが変分ベイズでは変分下界の引数として近似分布qを考える．$\mathcal{B}(q)$を最大化する近似分布$q$を求めることが変分ベイズの目的となる．&#xA;変分：関数による汎関数の微分 汎関数：関数を引数とする関数 変分ベイズにおける変分下界 EMアルゴリズムにおける変分下界 $$\mathcal{B}(\theta,\hat{\theta})=\log p(x|\theta)-\mathcal{D}(p(z|\hat{\theta})||p(z|x,\theta))$$&#xA;変分ベイズにおける変分下界 $$\mathcal{B}(q)=\log p(x) - \mathcal{D}(q(w)||p(w|x))$$&#xA;変分ベイズではパラメータと潜在変数をまとめて$w$で表すため，変分下界の引数として$\theta,\hat{\theta}$を使うことができない．そこで近似分布$q$自体を引数とする． $x$は観測済みであるため，$p(x)$は定数である．変分下界を大きくするためには，近似分布$q(w)$を真の分布$p(w|x)$に近づけることでKLダイバージェンス$\mathcal{D}(q(w)||p(w|x))$を小さくする必要がある．&#xA;変分下界の式変形 変分ベイズにおける変分下界を式変形すると以下のようになる．&#xA;$$\mathcal{B}(q)=\int q(w)\log \frac{p(x,w)}{q(w)}dw$$&#xA;よって期待値の形で以下のように表すことができる．&#xA;$$\mathcal{B}(q)=E_{q(w)}[\log p(x,w)] - E_{q(w)}[\log q(w)]$$&#xA;以上より，2つの対数尤度の差の最小化問題として扱うことができる．&#xA;参考 手塚 太郎，&amp;quot;しくみがわかるベイズ統計と機械学習&amp;quot; </description>
    </item>
    <item>
      <title>EMアルゴリズム2(変分下界とKLダイバージェンス)</title>
      <link>https://yuhi-sa.github.io/posts/20210317_bayes/10/</link>
      <pubDate>Wed, 17 Mar 2021 13:05:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20210317_bayes/10/</guid>
      <description>EステップとMステップを繰り返すだけで，EMアルゴリズムがうまく推定できる理由について理解するために，変分下界とKLダイバージェンスという概念を導入する．&#xA;変分下界 EMアルゴリズムにおける変分下界は以下のように定義される．&#xA;$$\mathcal{B}(\theta,\hat{\theta})=\int p(z|x,\hat{\theta}) \log \frac{p(x,z|\theta)}{p(z|x,\hat{\theta})}dz$$&#xA;変分下界の式を変形する&#xA;$$\mathcal{B}(\theta,\hat{\theta})=\log p(x|\theta)-(\int p(z|x,\hat{\theta}\log\frac{p(z|x,\hat{\theta})}{p(z|x,\theta)}dz)$$&#xA;これは第一項が，対数尤度，第二項がKLダイバージェンスを表している． これにより変分下界はQ関数とエントロピーの和となっていることがわかる．&#xA;$$\mathcal{B}(\theta,\hat{\theta})= Q(\theta,\hat{\theta})+H(p(z|x,\hat{\theta}))$$&#xA;KLダイバージェンス KLダイバージェンス$\mathcal{D}(q||p)$は，分布qと分布pの比の対数の期待値として定義され，分布どうしの距離を測るために使われる．&#xA;$$\mathcal{D}(q||p)=\mathbb{E}[\log\frac{q}{p}]\int q(x)\log \frac{q(x)}{p(x)}dx$$&#xA;2つの分布が類似しているほどKLダイバージェンスは小さくなり，完全に一致する場合0となる．また，Jensenの不等式より非負性が証明されている．&#xA;$\hat{\theta}$の更新 分布が一致し，KLダイバージェンスが0になるため変分下界$\mathcal{B}$が増加する． $\theta$の更新 Q関数を最大化することにより，変分下界$\mathcal{B}$も増加する．エントロピー$H$は$\theta$が含まれないため変化しない． 以上より，EMアルゴリズムによって変分下界が増加していく．変分下界とKLダイバージェンスの和である対数尤度は常に変分下界より大きいため，対数尤度も増加していく．よってEMアルゴリズムは対数尤度を増加させる．&#xA;参考 手塚 太郎，&amp;quot;しくみがわかるベイズ統計と機械学習&amp;quot; </description>
    </item>
    <item>
      <title>EMアルゴリズム</title>
      <link>https://yuhi-sa.github.io/posts/20210317_bayes/9/</link>
      <pubDate>Wed, 17 Mar 2021 13:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20210317_bayes/9/</guid>
      <description>あるフィットネスクラブにおける利用者の年齢分布のヒストグラムを考えると，筋トレを目的とした20代層とメタボ対策を目的とした50代層がおおきくなることが考えられる．&#xA;モデル化を考えた場合，このグラフの会員を2つのグループに分けそれぞれについて正規分布の最尤推定を行うことで2つの正規分布を得て，それらを重ね合わせて混合ガウスモデルを作成することを考える．&#xA;ここで，30代層は２つの山の裾野が重なる領域となるため扱いに困る．そこで，会員の目的は筋トレとメタボ対策の可能性が半分ずつとみなす．このように会員がどれだけの可能性で各潜在クラスjに所属するのかを負担率$r_{ij}$とよび，負担率をパラメータ推定の重みとしてかける．&#xA;負担率に基づく2つの正規分布のパラメータ推定と，2つの正規分布にもとづく負担率の計算を交互に行っていけば，次第に両者が良い値に近づくだろうというのがEMアルゴリズムの基本的な考え方となっている．&#xA;混合ガウスモデル 複数の正規分布が重なり合って作られる混合ガウスモデルを用いて潜在変数変数を含むモデルをどう定義するかをまとめる．&#xA;Q関数 $$p(x,z|\theta)=\Pi_{i=1}^np(x^{(i)},z^{(i)}|\theta)$$&#xA;観測変数xと潜在変数zの値を共に知ることができるという仮想的な状況におけるデータを完全データとよび，観測変数xの値のみしかわからない状況におけるデータを不完全データとよぶ． $p(x,z|\theta)$は完全データについて同時分布である． zは未知の値であるが，パラメータの推定量$\hat{\theta}$と観測値により決まる$p(z|x,\hat{\theta})$を使って完全データ$\log p(x,z|\theta)$の期待値を求めたものをQ関数と呼ぶ．&#xA;$$Q(\theta,\hat{\theta})=\mathbb{E}_{p(z|x,\hat{\theta})}[\log p(x,z|\theta)]=\int p(z|x,\hat{\theta})\log p(x,z|\theta)dz$$&#xA;Q関数は完全データの対数尤度の期待値であり，EMアルゴリズムではQ関数の最大化を考える&#xA;EMアルゴリズムによる混合ガウスモデルのパラメータ推定の更新式 参考 手塚 太郎，&amp;quot;しくみがわかるベイズ統計と機械学習&amp;quot; </description>
    </item>
    <item>
      <title>共役事前分布</title>
      <link>https://yuhi-sa.github.io/posts/20210317_bayes/8/</link>
      <pubDate>Tue, 16 Mar 2021 16:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20210317_bayes/8/</guid>
      <description>事後分布の式がシンプルになるように，以下の共役事前分布を用いることが標準的となっている．&#xA;ディリクレ分布 多項分布に対する共役事前分布はディリクレ分布$\mathcal{D}(\mu|\alpha)$である．&#xA;$$\mathcal{D}(\mu|\alpha)= \frac{\Gamma(\sum_{j=1}^{k}\alpha_j)}{\Pi_{j=1}^k\Gamma(\alpha_j)}\Pi_{j=1}^k\mu_j^{\alpha_j-1}$$&#xA;ここで，$\alpha$はディリクレ分布のパラメータであり，$\Gamma$は以下に示すガンマ関数である．&#xA;$$\Gamma(x)=\int_0^\infty t^{x-1}e^{-t}dt$$&#xA;ベータ分布 二項分布の事前分布として使えるのがベータ分布である．&#xA;$$p(\mu|a,b)=\frac{1}{B(a,b)}\mu^{\alpha-1}(1-\mu)^{b-1}$$&#xA;ここで，$B(a,b)$は2次元の多項ベータ関数を表す．&#xA;$$B(a,b)=\int_0^1\mu^{a-1}(1-\mu)^{b-1}d\mu$$&#xA;ガンマ分布 観測値が正規分布$\mathcal{N}(x|\mu,\sigma^2)$に従うとする時，その平均パラメータ$\mu$に対してベイズ推定を行うための共役事前分布としては正規分布$\mathcal{N}(\mu|\Psi,\rho^2)$が使える． 分散$\sigma^2$に対してベイズ推定を行う場合を考える． $\sigma^2$の事前分布として正規分布$\mathcal{N}(\sigma^2|\phi,\eta^2)$を使うと，事後分布は事前分布と同じ関係式にならない．(理由は参考資料のp97) そこで，分散の逆数$\lambda=1/\sigma^2$を精度パラメータとよび，精度パラメータの共役事前分布として，ガンマ分布$\mathcal{G}(\lambda|\kappa,\xi)$を用いる．&#xA;$$\mathcal{G}(\lambda|\kappa,\xi)=\frac{\xi^\kappa}{\Gamma(\kappa)}\lambda^{\kappa-1}\exp(-\xi\lambda)$$&#xA;$\kappa$は形状パラメータ，$\xi$はレートパラメータと呼ばれる．&#xA;ガンマ分布の余談 $\kappa=1$のガンマ分布は指数分布と一致する．&#xA;$$\mathcal{G}(\lambda|1,\xi)=\frac{\xi}{\Gamma(1)}\exp(-\xi\lambda)=\xi\exp(-\xi\lambda)$$&#xA;$\xi=\frac{1}{2}$に設定し$\nu=2\kappa$で定義されるパラメータで表したものは$\chi^2$分布と呼ばれる．&#xA;$$\chi^2(\lambda|\nu)=\mathcal{G}(\lambda|\frac{\nu}{2},\frac{1}{2})$$&#xA;正規-ガンマ分布 正規分布$\mathcal{N}(\mu,\lambda^{-1})$のパラメーターについて平均$\mu$は正規分布，精度$\lambda$についてはガンマ分布が事前分布として使えることを述べた． 今回は，$\mu$と$\lambda$を同時に求めることを考える． $\mu$と$\lambda$の同時分布を正規-ガンマ分布$\mathcal{NG}$とよぶ．&#xA;$$\mathcal{NG}(\mu,\lambda|\psi,\beta,\kappa,\xi)=\mathcal{N}(\mu|\psi,(\beta \lambda)^{-1}\mathcal{G}(\lambda|\kappa,\xi)$$&#xA;一般的な確率分布のパラメータとその共益事前分布 参考 手塚 太郎，&amp;quot;しくみがわかるベイズ統計と機械学習&amp;quot; </description>
    </item>
    <item>
      <title>ラグランジュの未定数法</title>
      <link>https://yuhi-sa.github.io/posts/20210317_bayes/7/</link>
      <pubDate>Tue, 16 Mar 2021 15:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20210317_bayes/7/</guid>
      <description>制約付き最適化のうち，制約条件が等式で合わされる場合によく用いられるのがラグランジュの未定乗数法である．&#xA;２接線が重なる点を求めるには勾配を求めることが有効である． 勾配は勾配作用素$\nabla$を用いて以下のように定義される．&#xA;$$\nabla f = (\frac{df}{dx}, \frac{df}{dy})$$&#xA;目的関数fを制約gのもとで解くことくを考えると．&#xA;$$\nabla f(\mu) = \lambda \nabla g(\mu)$$&#xA;が成り立ち，$\mu$が制約付き最適化の答えの候補となる． ここで，$\lambda$はラグランジュ未定乗数と呼ばれる．&#xA;ラグランジュ関数を以下のように定義すると，&#xA;$$\mathcal{L}(\mu,\lambda)=f(\mu)-\lambda g(\mu)$$&#xA;ラグランジュの未定乗数法は，$\nabla \mathcal{L}=0$を満たす$\mu$と$\lambda$，すなわちラグランジュ関数の勾配が0になる変数の値を見つけることとなる．&#xA;例1 $g(x,y)=2x+y+1=0$という制約条件を満たすx,yで$f(x,y)=x^2+y^2$を最小化するものを求める．&#xA;$$\nabla f(x,y) = (2x,2y)$$&#xA;$$\lambda \nabla g(x,y) = (2\lambda, \lambda)$$&#xA;よって，&#xA;$2x = 2\lambda$ $2y = \lambda$ さらに$g(x,y)=2x+y+1=0$を用いて計算すると，$x=-2/5,y=-1/5,$となる．&#xA;多項分布の最尤推定 ラグランジュの未定乗数法を多項分布の最尤推定に利用する．この場合，fは多項分布の対数，gは制約からくる$\sum_{j=1}^k\mu_j-1$となる．&#xA;$$f= \frac{(\sum_{j=1}^kx_j)!}{\Pi_{j=1}^kx_j!}\Pi_{j=1}^k\mu_j^{x_j}$$&#xA;$$g=\sum_{j=1}^k\mu_j-1$$&#xA;ラグランジュの未定乗数法より&#xA;$$\nabla (\frac{(\sum_{j=1}^kx_j)!}{\Pi_{j=1}^kx_j!}\Pi_{j=1}^k\mu_j^{x_j})=\lambda \nabla(\sum_{j=1}^k\mu_j-1)$$&#xA;両辺を$\hat{\mu}_h$で微分すると&#xA;$$\frac{x_h}{\hat{\mu}_h}=\lambda$$&#xA;制約条件を用いて$\lambda$を求めると&#xA;$$\lambda = \sum_{h=1}^k \hat{\mu}_h=m(試行の総和)$$&#xA;したがって，&#xA;$$\hat{\mu}_j=\frac{x_j}{\lambda}= \frac{x_j}{m}$$&#xA;参考 手塚 太郎，&amp;quot;しくみがわかるベイズ統計と機械学習&amp;quot; </description>
    </item>
    <item>
      <title>二項分布とその仲間たち</title>
      <link>https://yuhi-sa.github.io/posts/20210317_bayes/6/</link>
      <pubDate>Tue, 16 Mar 2021 14:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20210317_bayes/6/</guid>
      <description>&#xA;ベルヌーイ分布 まず，離散変数のとりうる値が2種，すなわち0か1のいずれかの値をとる場合を考える． 1が現れる確率を$\mu$,0が現れる確率を$1-\mu$とする．$\mu$は0から1までをとる．このように定義される分布をベルヌーイ分布とよぶ．&#xA;$$p(x|\mu)=\mu^x(1-\mu)^{1-x}$$&#xA;このように確率変数を引数として，その値が確率であるような関数は確率質量関数とよばれる．&#xA;二項分布 ベルヌーイ分布の試行回数を増やすことを考える．&#xA;$$p(r|m,\mu)=\frac{m!}{r!(m-r)!}\mu^r(1-\mu)^{m-r}$$&#xA;多項分布 サイコロの確率を考える場合，取りうる値を1から6まで拡張する必要がある．ベルヌーイ分布や二項分布を一般化したものの多項分布とよぶ．&#xA;$$p(x|\mu)=p(x_1,x_2,&amp;hellip;,x_k|\mu_1,\mu_2,&amp;hellip;,\mu_k)=\frac{(\sum_{j=1}^kx_j)!}{\Pi_{j=1}^kx_j!} \Pi_{j=1}^k\mu_{j}^{x_j}$$&#xA;$m=1$の場合をマルチヌーイ分布とよぶ．&#xA;$$\mathcal{M}(x|\mu)=p(x|\mu)=\Pi_{j=1}^k\mu_j^{x_j}$$&#xA;参考 手塚 太郎，&amp;quot;しくみがわかるベイズ統計と機械学習&amp;quot; </description>
    </item>
    <item>
      <title>ベイズ推定</title>
      <link>https://yuhi-sa.github.io/posts/20210317_bayes/5/</link>
      <pubDate>Tue, 16 Mar 2021 13:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20210317_bayes/5/</guid>
      <description>最尤推定に事前知識を加えることでより妥当な推定にすることを考える． 事前知識の事前分布$p(\theta)$と呼ぶ．&#xA;事前分布$p(\theta)$：パラメータ$\theta$がどのような値であるかについて，観測値がない状態での新念の分布&#xA;ベイズの定理 確率変数を$x$,パラメータを$\theta$として&#xA;$p(\theta|x)=\frac{p(\theta,x)}{p(x)}$ $p(x|\theta)=\frac{p(x,\theta)}{p(\theta)}$ の2式が成り立つことより $p(\theta|x)p(x)=p(\theta,x)=p(x,\theta)=p(x|\theta)p(\theta)$ が成り立ち，以下の式が求まる．&#xA;$$p(\theta|x)=\frac{p(x|\theta)p(\theta)}{p(x)}$$&#xA;これがベイズの定理である． ベイズの定理において&#xA;$p(\theta|x)$を事後分布 パラメータ$\theta$がどのような値であるかについて，観測値xの値を知った状態での新念の分布 $p(\theta)$を事前分布 $p(x|\theta)$を尤度 $p(x)$を規格化定数&#xA;$p(x)$は分子の総和が1となるように規格化するための定数であり，周辺化によって求める． $p(x)=\int p(x,\theta&amp;rsquo;)d\theta&amp;rsquo;=\int p(x|\theta&amp;rsquo;)P(\theta&amp;rsquo;)d\theta&amp;rsquo;$ とよぶ． MAP推定 事後確率$p(\theta|x)$を最大にする最尤推定量$\theta$を求める．&#xA;$$\hat{\theta}=arg\max_{\theta} p(\theta|x)=arg\max_{\theta}\frac{p(x|\theta)p(\theta)}{p(x)} $$&#xA;ベイズ推定 MAP推定では，事後分布$p(\theta|x)$を最も大きくする$\theta$の値が推定量$\hat{\theta}_{MAP}$として点推定される．しかし，これでは予測値の分布がわからない． そこで，ベイズ推定では$\theta$をひとつに求めるのではなく，事後分布$p(\theta|x)$を使って予測を行う．&#xA;たとえば，予測したいのが確率変数yの分布である場合，$p(\theta|x)$による期待値を計算する．&#xA;$$p(y|x) = \mathbb{E}_{p(\theta|x)}[p(y|\theta)]\int p(y|\theta)p(\theta|x)d\theta=\int p(y,\theta|x)d\theta$$&#xA;得られた分布$p(y|x)$に基づいて予測値をひとつに定めたい場合はyについての期待値を求めればいい．&#xA;$$\hat{y}=\mathbb{E}_{p(y|x)}[y]=\int yp(y|x)dy = \int y p(y|\theta)p(\theta|x)d\theta dy$$&#xA;このようにベイズ推定では，事前確率$p(\theta)$と尤度関数$p(x|\theta)$，ならびに観測値xに基づき事後確率$p(\theta|x)$を求める．&#xA;ベイズ更新 データが増えるたび，過去に推定した事後分布とベイズの定理を使って事後分布を更新していくことをベイズ更新と呼ぶ．&#xA;$$p(\theta|x^{(1)},x^{(2)},\alpha)= \frac{p(x^{(2)|\theta}p(\theta|x^{(1)},\alpha))}{p(x^{(2)}|\alpha)}$$&#xA;時刻tまでの観測値に基づく事後分布$p(\theta|x^{(1)},&amp;hellip;,x^{(t)},\alpha)$を事前分布として使い，観測値$x^{t+1}$も考慮した場合の事後分布$p(\theta|x^{(1)},&amp;hellip;,x^{t+1},\alpha)$が計算される．&#xA;ベイズ更新では，一度使用した観測値をふたたび使う必要がないため，記憶容量が少なくて済む．&#xA;参考 手塚 太郎，&amp;quot;しくみがわかるベイズ統計と機械学習&amp;quot; </description>
    </item>
    <item>
      <title>正規分布における最尤推定</title>
      <link>https://yuhi-sa.github.io/posts/20210317_bayes/4/</link>
      <pubDate>Tue, 16 Mar 2021 13:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20210317_bayes/4/</guid>
      <description>20世紀初頭に統計学者ロナウド・フィッシャーにより提案された統計的推定手法．&#xA;最尤推定 尤度とは，$x$を観測値,$\theta$をパラメータとしたときの条件付き確率$p(x|\theta)$である．このとき，$p(x|\theta)$はパラメータが$\theta$であるときの観測値$x$の確率分布である．&#xA;$$p(x|\theta)=\Pi_{i=1}^np(x^i|\theta)$$&#xA;この尤度関数$p(x|\theta)$を最大化する$\theta$を求める方法を最尤推定とよぶ．&#xA;正規分布における最尤推定 統計学や機械学習では指数分布の形をした確率分布を使うことが多いため，式変形の簡単化から対数尤度関数$\log p(x|\theta)$の最大化を行う場合が多い．&#xA;ここでは，観測値xが正規分布に従って生成されるモデルを考える．正規分布のもつパラメータは$\mu$と$\sigma$であり，これらが$\theta$に相当する．&#xA;$\mu$の推定 正規分布の対数尤度関数を式変形する&#xA;$$\log p(x|\mu,\sigma) = - \frac{\sum_{i=1}^n(x^i-\mu)^2}{2\sigma^2}-\frac{n}{2}\log \sigma^2-\frac{n}{2}\log2\pi$$&#xA;この右辺を最大化する$\mu$を求めたいので，$\mu$で微分する．&#xA;$$\frac{d \log p(x|\mu,\sigma)}{d\mu}=\frac{\sum_{i=1}^n(x^i-\mu)}{\sigma^2}$$&#xA;これが，0となる場合&#xA;$$\mu = \frac{1}{n}\sum_{i=1}^nx^i$$&#xA;観測値$x^i$の平均が正規分布における$\mu$の最尤推定値となる． これが，算術平均が幾何平均よりも広く使われている理由となっている．&#xA;算術平均：$n$個の標本の値を足し合わせ，$n$で割ること 幾何平均：$n$個の標本の値をかけ合わせ，それの$n$乗根を求めること $\sigma^2$の推定 $\sigma^2$で正規分布の対数尤度関数を微分する．&#xA;$$\frac{d \log p(x|\mu,\sigma)}{d\sigma^2}= \frac{\sum_{i=1}^n(x^i-\mu)^2}{2(\sigma^2)^2}-\frac{n}{2\sigma^2}$$&#xA;これが，0となる場合&#xA;$$\sigma^2 = \frac{1}{n}\sum_{i=1}^n(x^i-\mu)^2$$&#xA;$\mu$の推定値である標本平均を上式に代入して得られるのが標本分散となる．&#xA;参考 手塚 太郎，&amp;quot;しくみがわかるベイズ統計と機械学習&amp;quot; </description>
    </item>
    <item>
      <title>確率の基礎</title>
      <link>https://yuhi-sa.github.io/posts/20210317_bayes/2/</link>
      <pubDate>Mon, 15 Mar 2021 13:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20210317_bayes/2/</guid>
      <description>用語 命題：真か偽のいずれかになりうる文 確率分布：命題に対してそれが生じる確率を与える対応関係．&#xA;確率分布に命題を引数として与えると確率が出力される． 事象：確率分布の入力となる命題 確率変数：確率的に値が決まる変数 同時確率・周辺確率・条件付き確率 同時確率 ２つの出来事が共に生じる確率．&#xA;$$p(x,y) = p(y,x)$$&#xA;周辺確率 確率変数$x$とyの同時確率$p(x,y)$から，片方の変数を足し合わせることにより$p(x)$もしくは$p(y)$を求めることを周辺化とよび，周辺化によって求まる$p(x),p(y)$を周辺確率と呼ぶ．&#xA;$$\int p(x,y) dx = p(y)$$&#xA;条件付き確率 確率変数xが定まった上で，確率変数$y$が起こる確率$p(y|x)$．&#xA;$$p(y|x)=\frac{p(x,y)}{p(x)}$$&#xA;確率変数の独立性 ２つの確率変数が依存関係を持たないとき，独立と表現する．$x$と$y$が独立である場合，以下の式を満たす．&#xA;$$p(x,y)=p(x)p(y)$$&#xA;独立でない場合を従属と呼ぶ．&#xA;条件付き独立性 独立ではないが，ある条件が定まった後は独立となる．&#xA;$$p(x,y|z)=p(x|z)p(y|z)$$&#xA;連続変数の分布 たとえば時速のような連続値を確率変数として考える場合，1.00km/hである確率，1.01km/hである確率など無限になる可能性がある．無限の可能性のそれぞれに0より大きい確率を割り当てると総和が無限となってしまう．(確率の総和は1)&#xA;→累積確率関数，確率密度関数を用いる&#xA;累積確率関数 累積確率関数F(x)は「確率変数の値がx以下である確率」を表す．&#xA;確率密度関数 確率密度関数は累積確率関数の微分として定義される．&#xA;さまざまな確率分布 指数分布：0に近い値ほど起きやすく．大きくなるほど起こりにくい．部品がどのタイミングで故障するかなど時間の長さの分布は指数分布に従う．自然界では放射性物質の半減期が指数分布に従う．$\lambda$はパラメータ $$p(x|\lambda)= \lambda \exp (-\lambda x) $$&#xA;ラプラス分布：指数分布の形を保ったまま定義域を負の範囲にも拡大することを考えた場合，積分が発散してしまう．そこで絶対値を用いて作られた分布．($x^2$を用いて作られた分布が正規分布) $$p(x|\lambda)= \frac{\lambda}{2} \exp (-\lambda |x|) $$&#xA;期待値 確率変数xが確立分布$p(x)$に従い，$x$によって値が決まる関数$f(x)$を考える．このとき，期待値は以下のように表される．&#xA;$$\mathbb{E}[f(x)]=\int p(x)f(x)dx$$&#xA;参考 手塚 太郎，&amp;quot;しくみがわかるベイズ統計と機械学習&amp;quot; </description>
    </item>
    <item>
      <title>正規分布(ガウス分布)</title>
      <link>https://yuhi-sa.github.io/posts/20210317_bayes/3/</link>
      <pubDate>Mon, 15 Mar 2021 13:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20210317_bayes/3/</guid>
      <description>連続変数の確率分布のうち，もっとも広く使われているものの一つである．正規分布が広く使われるのは，誤差が正規分布に従うことが多いためである．正規分布は，ガウスが星の位置を人間が観測した場合，実際の位置に対してどのようにばらつくかを調べる中で生まれた．&#xA;標準正規分布 もっとも基本的な正規分布．規格化(総和が1となるように調整する)のため$\sqrt{2 \pi}$で割っている．&#xA;$$p(x)=\frac{1}{\sqrt{2\pi}}\exp(-\frac{x^2}{2})$$&#xA;平行移動 標準正規分布は，0を中心としている分布であるが$\mu$を中心とした正規分布を作りたい場合，平行移動することを考える．&#xA;$$p(x|\mu)=\frac{1}{\sqrt{2\pi}}\exp(-\frac{(x-\mu)^2}{2})$$&#xA;スケーリング 標準正規分布を二階微分する． $$ \frac{d^2\mathcal{N}}{dx^2} = -\frac{1-x^2}{\sqrt{2\pi}}\exp(-\frac{x^2}{2})$$ よって，変曲点は+1,-1となる．&#xA;変曲点が$\sigma$の分布を作る場合，以下のようになる．&#xA;$$ p(x|0,\sigma^2)=\frac{1}{\sqrt{2\pi\sigma^2}}\exp(-\frac{x^2}{2\sigma^2})$$&#xA;平行移動とスケーリングをまとめて一般の正規分布$\mathcal{N}(x|\mu,\sigma^2)$が作られる．&#xA;$$\mathcal{N}(x|\mu,\sigma^2)=\frac{1}{\sqrt{2\pi\sigma^2}}\exp(-\frac{(x-\mu)^2}{2\sigma^2})$$&#xA;参考 手塚 太郎，&amp;quot;しくみがわかるベイズ統計と機械学習&amp;quot; </description>
    </item>
    <item>
      <title>統計学と機械学習の用語</title>
      <link>https://yuhi-sa.github.io/posts/20210317_bayes/1/</link>
      <pubDate>Mon, 15 Mar 2021 13:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20210317_bayes/1/</guid>
      <description>統計用語 標本：データを構成する個々の例 観測値：標本が持つ値 パラメータ：観測値がどのような値になるのかの傾向を決めている値(データに依存せずに決まる部分をモデル) 検定：データについての仮説が正しいかどうかを明らかにする． 推定：まだ観測されていない値の予測 機械学習用語 学習・訓練：プログラムにルールを獲得させる タスク：機械学習の目標 教師あり学習 入力と入力に対する出力の正解例(教師信号)を多数与えて，識別モデルを学習させる．&#xA;代表的なタスクは，分類と回帰&#xA;分類：入力をあらかじめきめられた有限個のカテゴリに分類する． 回帰：実数値を出力とする． 教師なし学習 生成モデルを学習させる．「このようなルールで分類，回帰を行う」という識別モデルに対して，生成モデルでは，「観測されたデータはこのように生成される」というメカニズムを表現する．&#xA;代表的なタスクは，クラスタリングと次元削減&#xA;クラスタリング：データのグループ分け 次元削減：入力をよりシンプルな表現に変換 参考 手塚 太郎，&amp;quot;しくみがわかるベイズ統計と機械学習&amp;quot; </description>
    </item>
    <item>
      <title>numpyからpytorchの変換で，dtypeを消す</title>
      <link>https://yuhi-sa.github.io/posts/20210215_pytorch_dtype/1/</link>
      <pubDate>Mon, 15 Feb 2021 13:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20210215_pytorch_dtype/1/</guid>
      <description>x = np.random.rand(5) print(x) torch_x = torch.tensor(x) print(torch_x) [0.07875406 0.96178392 0.64953209 0.12122955 0.92958997] tensor([0.0788, 0.9618, 0.6495, 0.1212, 0.9296], dtype=torch.float64) numpyの配列を，そのままtorchに変換するとdtypeが残る．&#xA;torch_x = torch.tensor(x.astype(np.float32)) print(torch_x) tensor([0.0788, 0.9618, 0.6495, 0.1212, 0.9296]) 消すためには，numpyの型をfloat32にしてからtorchに変換する必要がある．</description>
    </item>
    <item>
      <title>ニューラルネットワークを用いた教師あり学習のpythonプログラム</title>
      <link>https://yuhi-sa.github.io/posts/20210215_nn/1/</link>
      <pubDate>Mon, 15 Feb 2021 13:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20210215_nn/1/</guid>
      <description>ニューラルネットワークClassを作成 import torch from torch.autograd import Variable import torch.nn as nn import torch.nn.functional as F import torch.optim as optim import numpy as np nn.Moduleを継承して，ニューラルネットワーク(NN)のニューロン数，optimizer，損失関数を決める． 損失関数によって求まるlossを小さくするようにoptimizerがNNのパラメータを最適化することによって学習を行う．&#xA;optimizerの種類：【前編】Pytorchの様々な最適化手法(torch.optim.Optimizer)の更新過程や性能を比較検証してみた！ 損失関数の種類：pytorch for python における損失関数 (誤差関数) class Model(nn.Module): def __init__(self, input_dim, output_dim): super(Model, self).__init__() # NNの入出力 self.fc1 = nn.Linear(input_dim, 100) self.fc2 = nn.Linear(100, 100) self.fc3 = nn.Linear(100, output_dim) # 学習率とパラメータの更新方法 self.optimizer = optim.SGD(self.parameters(), lr=0.01) # loss関数 self.criterion = nn.MSELoss() 活性化関数を定義&#xA;活性化関数の種類：活性化関数一覧 (2020) def forward(self, x): x = F.</description>
    </item>
    <item>
      <title>markdownで記事を作成して無料ブログをつくる[Github Pages&#43;Hugo]</title>
      <link>https://yuhi-sa.github.io/posts/20210204_hugo/1/</link>
      <pubDate>Thu, 04 Feb 2021 13:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20210204_hugo/1/</guid>
      <description>はじめに Github Pagesを用いると，無料でwebサイトを公開できる．静的サイトジェネレータ(今回は，Hugoを利用)と組み合わせることでブログを簡単に作れることを知って，やってみたいなあと思って作ってみた．そのまとめ．Github Pages + 静的ジェネレータの記事はめちゃめちゃわかりやすい記事が何本もあったが，自分のまとめように作ってみた．&#xA;全体通して，参考にした記事たち 参考1：Hugo + GitHub Pages（独自ドメイン適応）でサイトを作成・公開する&#xA;参考2：【2018年版】Hugoとgithub pagesでブログ作る方法【Circle CIも回します】&#xA;Hugoとは ブログを作成する際，コンテンツの作成や編集のしやすさからWordPressのようなCMSを利用することが多い．しかし，CMSを使用するにはCMS自体のインストールや設定，データベースの準備など少し複雑な作業が必要となる．小規模なブログの場合，HTMLファイルを用いた静的なサイトを作成したほうがコストが低くなる場合がある．とはいえ，HTMLファイルをいちいち手動で作成するのはめんどくさい．そのため，HTMLファイルを半自動生成するようなツール(静的サイトジェネレータ)が存在し，その一つがHugoである．&#xA;Hugoは，Go言語で開発された静的サイトジェネレータである．Hugoを使うとデータベースを使用することなく静的なHTMLファイルやCSSファイルによるブログを作成できる．コンテンツは，Markdown形式で記述して，ビルドすると静的なHTMLファイルによるウェブサイトが生成される． Hugoのメリットしては，&#xA;ビルド，表示処理が早い データベース不要で管理が簡単 ということがあげられる．&#xA;参考1：静的サイトジェネレータ「Hugo」と技術文書公開向けテーマ「Docsy」でOSSサイトを作る&#xA;参考2：Hugoとは？静的サイトジェネレータについて解説&#xA;Hugoでサイトを作成 Hugoのインストール # Homebrew(macOS)の場合 brew install hugo その他の方法でのインストール方法は，Install Hugo&#xA;サイトの作成 hugo new site test # testは好きな名前 cd test hugo # このコマンドで生成 サーバーでプレビュー hugo server http://localhost:1313で確認できる&#xA;フォルダの中身の確認 . ├── archetypes # (初期生成されない)Hugo Pipes で処理するファイルを保存するためのファイル ├── config.toml # hugoの設定ファイル ├── content # 記事ファイルを置くファイル ├── data # サイトの全ページから参照したいデータを記述したファイル ├── layouts # テーマファイルを一部修正したいときやレイアウトパーツを追加したいときに利用するファイル ├── public # 生成されるhtmlなどのコード(これを公開する) ├── static # サイト内の静的ファイルを置くファイル └── themes # テーマファイルを置く 参考1：HUGO のディレクトリ構成</description>
    </item>
    <item>
      <title>Unscented Transformation(アンセンテッド変換,U変換)のpythonプログラム</title>
      <link>https://yuhi-sa.github.io/posts/20210125_ut/1/</link>
      <pubDate>Mon, 25 Jan 2021 15:17:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20210125_ut/1/</guid>
      <description>Unscented Transformation U変換は，標準正規分布に従う確率変数$x$の平均$\bar{x}$と分散共分散行列$P_x$が既知であるとき，$x$の非線形変換$y=f(x)$で変換される確率変数$y$の$\bar{y}$と$P_y$を推定する方法である．&#xA;まず，この場合，モンテカロ的に&#xA;$$ \bar{y}\simeq\frac{1}{N}\sum_{i=1}^Nf(x_i) $$&#xA;$$ P_y \simeq \frac{1}{N}\sum_{i=1}^N(f(x_i)-\bar{y})(f(x_i)-\bar{y})^T $$&#xA;のように計算することが思いつくが，精度をよく計算するにはNを大きくする必要があり，実用上問題がある．&#xA;線形近似をすることなく，モンテカロ法のよいところを利用できるように，できるだけ少ないサンプル点を用いて，変換後の確率変数の統計的性質を推定する方法がU変換である．&#xA;まず，確率変数$x$からサンプルする値(シグマ点)を決め，シグマ点を非線形変換し，変換した値から$y$の$\bar{y}$と$P_y$を求める．&#xA;参考1：UKF （Unscented Kalman Filter）っ て何 ？&#xA;import matplotlib.pyplot as plt import numpy as np import random import math import scipy.linalg 入力には$X=(X_1,X_2)$を用いる．&#xA;平均ベクトルは，&#xA;$$ \mu=(E[X_1],E[X_2])=(\bar{x}_1,\bar{x}_2) $$ 分散共分散ベクトルは，&#xA;$$ P_x = [ \begin{array}{cc} var[X_1] &amp;amp; cov[X_1,X_2] \ cov[X_2,X_1] &amp;amp; var[X_2] \end{array} ] = [ \begin{array}{cc} \sigma_1^2 &amp;amp; \sigma_1\sigma_2 \ \sigma_1\sigma_2 &amp;amp; \sigma_2^2 \end{array} ] $$&#xA;で表すことができる．&#xA;よって， $X_1,X_2$にそれぞれ平均0分散1，平均1分散2の標準正規分布を用いると考えると，</description>
    </item>
    <item>
      <title>遺伝的アルゴリズム(GA)を用いたニューラルネットワーク学習のpythonプログラム</title>
      <link>https://yuhi-sa.github.io/posts/20210109_nnga/1/</link>
      <pubDate>Sat, 09 Jan 2021 15:17:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20210109_nnga/1/</guid>
      <description>はじめに $$ f(x,y)=\frac{(\frac{\sin x^2}{cos y}+x^2-5y+30)}{80} $$ の関数を遺伝的アルゴリズムを用いてニューラルネットワークを学習させる．&#xA;遺伝的アルゴリズム(GA:Genetic Algorithms) GAはHollandによって開発された，生物の進化のメカニズムを模倣した最適解探索のプログラムである．有性生殖をする生物の進化の課程の中で，環境に適応できる個体ほど次世代に自分の遺伝子を残すことができ，2個体の交叉により子をつくる，また稀に突然変異がおこるという特徴に着目をしている．決定的な優れた厳密解法が発見されておらず，全探索が不可能と考えられるほど広大な解空間をもつ問題に有効とされており，様々な最適化問題に応用可能であり，今後もさらなる発展が期待される．&#xA;GAのアルゴリズム GAのアルゴリズムを以下に示す．&#xA;個体の初期生成： 初期の個体をランダムに生成する． 適合度(評価値)の算出 各個体の適合度(評価値)決定する． 再生 各個体の適合度に依存した個体の再生を行う．適合度の高い個体は増殖し，低い個体は淘汰される． 交叉 Step3で選択された個体群からランダムに選択された個体のペアから，新しい個体を生成する．これを既定回数繰り返す． 突然変異 突然変異確率に基づいて，各個体の遺伝子の一部をランダムに書き換える． 終了条件判定 終了条件を満たせば終了，そうでなければStep2に戻る． GAアルゴリズムの性質 GAでは再生により評価値の高い粒子を重点的に探索すると同時に，交叉と突然変異により広範囲に解を探索するため，これらの遺伝的操作が有効に動作すれば良好な解が発見されることが期待される．しかし，遺伝的操作により，最良解の情報を失い，局所解に陥ってしまうことがあり最適解をうまく発見できない場合がしばしばある．特に，制御パラメータの解空間は多数の局所解が存在しているため，交叉の操作は不向きであるといえる．また，GAは決定変数が離散な値であることを前提とした解探索手法であるが，制御パラメータの最適化のための解情報は連続値であることから解の探索に最適ではないことも考えられる．&#xA;プログラム 遺伝子はニューラルネットワークの重みと閾値から構成されるものとして，1つのニューラルネットワークが1つの個体に対応するように設計を行い，上記のGAの手法を用いて更新を行った．&#xA;パラメータなどを設定 # 世代 GEN = 100 # NNの個数 In = 2 Hidden = 2 Out = 1 # NNの個体数 Number = 1000 # 教師信号の数 Num = 1000 # 交叉確率 kousa = 0.8 # 突然変異確率 change = 0.05 # 学習する関数 def kansu(x): return((math.sin(x[0])*math.sin(x[0])/math.cos(x[1]))+x[0]*x[0]-5*x[1]+30)/80 # シグモイド関数 def sigmoid(x): return 1/(1+np.</description>
    </item>
    <item>
      <title>[Python]ベイズ推定に基づく線形回帰(最小二乗推定，最尤推定，MAP推定，ベイズ推定)</title>
      <link>https://yuhi-sa.github.io/posts/20210108_bayes/1/</link>
      <pubDate>Fri, 08 Jan 2021 15:17:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20210108_bayes/1/</guid>
      <description>背景 回帰問題の目的は，$N$個の観測値と対応する目標値からなる訓練データ集合が与えられたとき，新しい観測値に対する目標値の値を予測することである．今回扱う線形回帰モデルは，多項式は調節可能なパラメータの線形結合という特徴を利用した最も単純なモデルである．固定された基底関数の入力変数に関して非線型な関数の固定された集合結合をとることにより，有用な関数のクラスが得られる．&#xA;観測されたデータ$D={(x_i,y_i);i=1,2,&amp;hellip;,n}$に対して，基底関数の線形結合に基づく回帰関数モデルを以下のように定義する．ここで$\Phi$を$x$の基底関数，$\epsilon$を誤差項とする．&#xA;$$ y_i= \Phi w+ \epsilon $$&#xA;ベイズ線形回帰について 最小二乗推定 最小二乗推定は，回帰モデルによる予測誤差の二乗和$S(w)$を最小化する$\hat{w}$を求める手法である．$S(w)$を$w$で偏微分し，$\hat{w}$を求める．&#xA;$$ S(w)=\epsilon^{T}\epsilon=(y-\Phi w)^T(y-\Phi w) $$&#xA;$$ \frac{dS(w)}{dw}=-\Phi^{T}y+\Phi^T\Phi w $$ $\frac{dS(w)}{dw}=0$のときを考えると，&#xA;$$ \hat{w}=(\Phi^T\Phi)^{-1}\Phi^{T}y $$ 従って，最小二乗推定による予測モデルは以下のようになる．&#xA;$$ \hat{y}=\Phi\hat{w}=\Phi(\Phi^T\Phi)^{-1}y $$&#xA;最尤推定 最尤推定は，尤度$P(y,w)$を最大化する$\hat{w}$を求める手法である．誤差項に正規分布を仮定したモデルを考える．このとき観測値$y$は平均$\Phi w$，分散行列$\sigma^2I_n$のn次元正規分布に従う．よって尤度は，以下のように与えられる．&#xA;$$ y= \Phi w+ \epsilon,\epsilon \sim \mathcal{N}(0,\sigma^2I_n) $$ $$ P(y\mid w,\sigma^2)=\mathcal{N}(\Phi w,\sigma^2I_n) =\frac{1}{(2\pi\sigma^2)^{\frac{n}{2}}}exp{-\frac{1}{2\sigma^2}(y-\Phi w)^T(y-\Phi w)} $$&#xA;$P(y\mid w)$の対数を$w$で偏微分し，$\hat{w}$を求める．&#xA;$$ \log P(y\mid w) = -\frac{n}{2}\log(2\pi\sigma^2)-\frac{(y-\Phi w)^T(y-\Phi w)}{2\sigma^2} $$&#xA;$$ \frac{1}{P(y\mid w)}\frac{P(y\mid w)}{dw}=-(\Phi^{T}y+\Phi^{T}\Phi w) $$ $\frac{dP(y\mid w)}{dw}=0$のときを考えると．&#xA;$$ \hat{w}=(\Phi^T\Phi)^{-1}\Phi^{T}y $$</description>
    </item>
    <item>
      <title>情報理論(エントロピーから相互情報量, PRML1.6)</title>
      <link>https://yuhi-sa.github.io/posts/20210107_prml_ent/1/</link>
      <pubDate>Thu, 07 Jan 2021 15:17:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20210107_prml_ent/1/</guid>
      <description>情報量の表し方 情報量を測る尺度は確率分布$p(x)$に依存しており，確率$p(x)$の単調な関数$h(x)$で表されるものを考える． 情報量として用いる場合，以下の2点を満たしている必要がある．&#xA;$h(x,y)=h(x)+h(y)$ 2つの事象$x,y$が無関係なら，両方を観測したときの情報が，それぞれを別々に観測した情報の和となる． $p(x,y)=p(x)p(y)$ 2つの無関係な事象は統計的に独立である． この2つの関係から，対数を用いる．$p(x)$は1以下となるためマイナス記号を加え情報が0以上であることを保証する．&#xA;$$ h(x)=-log_2p(x) $$ 情報理論では一般的に底2が用いられる．&#xA;エントロピー ある送信者が確率変数を受信者に送りたいと考えた時，送られる情報の平均量は，分布$p(x)$の期待値を撮ったものとなり，これを確率変数$x$のエントロピーと呼ぶ．&#xA;$$ H[x]=-\sum_x p(x) \log_{2}p(x) $$&#xA;ビット数の下限 ある確率変数$x$が8個の{$a,b,c,d,e,f,g,h$}を送信する場合を考える．&#xA;8個それぞれの確率が等確率であるとする． $$ H[x]= -8*\frac{1}{8}\log_{2}\frac{1}{8}=3ビット $$&#xA;8個それぞれの確率が{$\frac{1}{2},\frac{1}{4},\frac{1}{8},\frac{1}{16},\frac{1}{64},\frac{1}{64},\frac{1}{64},\frac{1}{64},$}で与えられるとする． $$ H[x]=-\frac{1}{2}\log_2\frac{1}{2}-\frac{1}{4}\log_2\frac{1}{4}-\frac{1}{8}\log_2\frac{1}{8}-\frac{1}{16}\log_2\frac{1}{16}-\frac{4}{64}\log_2\frac{1}{64}=2ビット $$&#xA;上記の例2のように非一様な場合は，よく起きる事象に短い符号を使い，あまり起きない事象に長い符号を割り当てることにより効率よく通信を行うことができる． ノイズなし符号化定理では，確率変数の状態を送るために必要なビット数の下限がエントロピーであることを主張している．&#xA;エントロピーの高低 少ない値で鋭いピークを持つようば分布でエントロピーは低く，薄く広がってる分布はエントロピーが高い．&#xA;最大のエントロピーを持つ確率分布 まず，エントロピーの二階微分二階微分を計算する．&#xA;$$ \frac{\delta H[x]}{\delta p(x_i)\delta p(x_j)}=-I_{ij}\frac{1}{p_i} $$ $I$は単位行列である．二階微分が負であるため上に凸なグラフとなり．停留点が最大値であることがわかる．&#xA;微分エントロピー $x$を等間隔の区間$\Delta$にわけることを考えると，平均値の定理より，以下の式を満たす$x_i$が存在する．&#xA;$$ \int_{i\Delta}^{(i+1)\Delta}p(x)dx = p(x_i)\Delta $$ $x_i$の値を観測する確率は，$p(x_i)\Delta$となる．よって離散分布のエントロピーは，以下のようになる．&#xA;$$ H_{\Delta}=-\sum_ip(x_i)\Delta\ln(p(x_i)\Delta)= -\sum_i p(x_i)\Delta\ln p(x_i)- \ln \Delta $$ 第二項を無視して$\Delta\rightarrow 0$の極限を考える．&#xA;$$ \lim_{\Delta\rightarrow 0}{ -\sum_i p(x_i)\Delta\ln p(x_i) } = -\int p(x)\ln p(x)dx $$ 右辺が微分エントロピーとなる．</description>
    </item>
    <item>
      <title>粒子群最適化(PSO)とTCPSOのMatlabプログラム</title>
      <link>https://yuhi-sa.github.io/posts/20210107_pso_tcpso/1/</link>
      <pubDate>Thu, 07 Jan 2021 15:17:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20210107_pso_tcpso/1/</guid>
      <description>粒子群最適化(PSO:Particle Swarm Optimization) PSOは，Kennedy and Eberhartによって開発された，魚や鳥などにみられる群行動の餌の在り処の情報が群全体に伝達され，他の個体の行動に合わせて速度を調整しながらすべての個体が一斉に行動しているという点に着目して提案された最適解探索のアルゴリズムである．&#xA;PSOでは，位置情報と速度情報を持った粒子(個体)が最適解を求めて探索空間を探索する．各粒子は自分自身の過去の情報と周りの粒子の過去の情報を互いに共有しながら解を探索する．粒子の更新が単純な概念から容易に実装でき，さらに多様な改良が可能である．&#xA;粒子の更新 粒子$i,i=1,2,…,n$は時刻$t$における位置情報ベクトル$x_i(t)=(x_i1,x_i2,…,x_m)$と速度ベクトル$v_i (t)=(v_i1,v_i2,…,v_m)$の情報を持っている．&#xA;このとき，$n$は粒子数，$m$は次元数である．粒子$i$が各時刻まで探索した解のうち最良の位置情報ベクトルを$P_i(t)$として保持し，粒子群の中で最良の粒子の位置情報ベクトルを$P_G(t)$として群全体で共有する．&#xA;以下に位置情報ベクトルと速度ベクトルの更新式を示す．&#xA;$$ v_i(t+1)=w{v}_i(t)+C_1r_1(P_i(t)-m{x}_i(t))+C_2r_2(P_G(t)-x_i(t)) $$&#xA;$$ x_i(t+1)=x_i(t)+{v}_i(t+1) $$&#xA;$w$は慣性項に対する重み，$C_1$は自身の最良位置に対する重み，$C_2$は全体の最良位置に対する重みである．&#xA;また，$r_1,r_2∈[0,1]$は各次元ごとに毎期生成される一様分布に従ってランダムに決定される実数値である．&#xA;更新の概念図を以下に示す． アルゴリズム PSOのアルゴリズムを以下に示す．&#xA;粒子の初期生成 初期の粒子の位置情報ベクトル$x_i$と速度ベクトル$v_i$を乱数に基づいて生成する． 評価値の算出 各粒子の位置から評価値を決定する． 探索開始($t=0$)から現在までの各粒子$i$の最良位置 情報$P_G (t)$の更新，各粒子ごとに，現在までの最良の評価値を記録する． 群全体の最良位置情報$P_G (t)$の更新 全粒子の中から，最良の評価値を記憶する． 各粒子の速度を計算 各粒子の位置を計算 終了条件判定 終了条件を満たすまで，Step2からStep6を繰り返す． アルゴリズムの性質 単純な算術演算により構成され，パラメータ$w，C_1，C_2$への依存性が高いことや，各粒子が群全体の最良位置情報$P_G (t)$の位置に集中してしまうことで局所解に陥り，十分な探索ができないといった問題が存在する．収束速度と多様性の維持のバランスが難しい．&#xA;以下に，粒子数100個をランダムに生成し，$(x,y)=(0,0)$からの距離の逆数を評価値としてPSOを行った例を示す．&#xA;$t=0$のとき $t=250$のとき $t=500$のとき 収束は早いが，局所解に陥っていることがわかる．また，慣性項の影響で集中的に探索することが難しくなっている．&#xA;TCPSO(Two-swarm Cooperative Particle Swarm Optimization) TCPSOでは大域的な探索を行うマスター粒子群と集中的な探索を行うスレーブ粒子群を用いることで，PSOの収束速度と多様性の問題を改善する．2つの粒子群がお互いに情報を共有しながら各粒子が位置と速度の更新を行う．性質の異なる粒子群を用いることで大域探索と集中探索を行うことが可能になり，効率的な解探索が可能になる．&#xA;粒子の更新 スレーブ粒子を添字$S$，マスター粒子を添字$M$で表す．以下に位置情報ベクトルと速度ベクトルの更新式を示す．&#xA;$$ v_i^S(t+1)=C_1^Sr_1(P_i^S(t)-x_i^S(t))+C_2^Sr_2(P_G(t)-x_i^S(t)) $$ $$ x_i^S(t+1)=x_i^S(t)+v_i^S(t+1) $$ $$ v_i^M(t+1)=w^Mv_i^M(t)C_1^Mr_1(P_i^M(t)-x_i^M(t)) +C_2^Mr_2(P_G^S(t)-x_i^M(t))+C_3^Mr_3(P_G(t)-x_i^M(t)) $$ $$ x_i^M(t+1)=x_i^M(t)+v_i^M(t+1) $$ マスター粒子の速度の更新には，スレーブ粒子群の全体の最良位置$P_G^S (t)$が追加されており，スレーブ群の情報を更新することで多様性を保持しながら大域的な探索をすることが可能になっている． スレーブ粒子とマスター粒子の更新の概念を以下に示す．&#xA;スレーブ粒子群の更新の概念図 マスター粒子群の更新の概念図 アルゴリズム TCPSOのアルゴリズムを以下に示す．</description>
    </item>
    <item>
      <title>SQLの表の作成</title>
      <link>https://yuhi-sa.github.io/posts/20211121_db/7/</link>
      <pubDate>Mon, 04 Jan 2021 10:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20211121_db/7/</guid>
      <description>表の作成 CREATE TABLE 表名 (列名 データ型 [DEFAULT値] 制約, ... 列名 データ型 [DEFAULT値]　制約,) データ型 文字型：CHAR(size),VARCHAR(size) 数値型：INT,INTEGER,BIGINT,FLOAT,DOUBLE 日付型：DATETIME 制約 NOT NULL：NULL値を禁止 UNIQUE：同一値の入力禁止 PRIMARY KEY：主キー制約 FOREIGN KEY：外部キー制約 コピー表の作成 副問合せを利用することにより，結果表をコピーして表を作成できる．&#xA;CREATE TABLE 表名[(列名,列名,...)] 副問合せ; ビュー表の作成 ビューは表または別のビューをもとにした仮装の表のことである．ビュー自体にはデータは格納されず，参照元の変更が反映される．&#xA;CREATE VIEW ビュー名[(列名,列名,...)] AS 副問合せ; 表の変更 属性の変更 ALTER TABLE 表名 MODIFY 列名 データ型; 列の追加 ALTER TABLE 表名 ADD 列名 データ型[DEFAULT 値]; 表名の変更 RENAME TABLE 旧表名 TO 新表名; 表の削除 DROP TABLE 表名; </description>
    </item>
    <item>
      <title>SQLのデータ挿入，更新，削除</title>
      <link>https://yuhi-sa.github.io/posts/20211121_db/6/</link>
      <pubDate>Fri, 01 Jan 2021 10:00:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20211121_db/6/</guid>
      <description>データ挿入 INSERT INTO 表名 VALUES(値1,値2,...); データの更新 UPDATE 表名 SET 列名 = 式; (ex, a = 0.9*a;) データの削除 DELETE FROM 表名 </description>
    </item>
    <item>
      <title>Pythonでslackに実験結果(テキストと画像)を送る</title>
      <link>https://yuhi-sa.github.io/posts/20201223_slack_api/1/</link>
      <pubDate>Wed, 23 Dec 2020 15:17:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20201223_slack_api/1/</guid>
      <description>テキストを送る slack側のAPIを設定 slackの「設定と管理」から「アプリを管理する」を開く． AppディレクトリIncoming Webhookを検索して追加する． チャンネルを選択して，「Incoming Webhookインテグレーションの追加」 「Webhook URL」をコピーする． botのアイコンと名前をここで変更できる． コード import slackweb slack = slackweb.Slack(url=&amp;#34;コピーした Webhook URL&amp;#34;) def notify(title, text, color): attachments = [{&amp;#34;title&amp;#34;: title, &amp;#34;text&amp;#34;: text, &amp;#34;color&amp;#34;: color, #good, warning, danger &amp;#34;footer&amp;#34;: &amp;#34;Send from Python&amp;#34;, }] slack.notify(text=None, attachments=attachments) notify(&amp;#34;テスト&amp;#34;,&amp;#34;おはよう&amp;#34;,&amp;#34;good&amp;#34;) notify(&amp;#34;テスト&amp;#34;,&amp;#34;こんにちは&amp;#34;,&amp;#34;warning&amp;#34;) notify(&amp;#34;テスト&amp;#34;,&amp;#34;こんばんは&amp;#34;,&amp;#34;danger&amp;#34;) attachmentsの構文は，以下を参考&#xA;Creating rich message layouts Slack API attachmentsチートシート 実行結果 画像を送る slack側のAPIを設定 上記の1から2と同様にして「Bots」を追加する． API トークンをコピーする． コード import requests import json def notifyImg(title, imageURL): files = {&amp;#39;file&amp;#39;: open(imageURL, &amp;#39;rb&amp;#39;)} param = { &amp;#39;token&amp;#39;: &amp;#34;コピーした APIトークン&amp;#34;, &amp;#39;channels&amp;#39;:&amp;#39;投稿したいチャンネル名&amp;#39;, &amp;#39;filename&amp;#39;:&amp;#34;filename&amp;#34;, &amp;#39;title&amp;#39;: title, } requests.</description>
    </item>
    <item>
      <title>楕円曲線上のElGamal暗号のpythonプログラム</title>
      <link>https://yuhi-sa.github.io/posts/20201223_elgamal/1/</link>
      <pubDate>Wed, 23 Dec 2020 15:17:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20201223_elgamal/1/</guid>
      <description>鍵生成 楕円曲線$E/F_p$と位数$l$のベーズポイント$G$を生成する．($p,l$は素数) 秘密鍵$x$を乱数にて生成し，$E$上で$Y=xG$を計算する． ここで，秘密鍵$x$，公開鍵$E,G,Y$&#xA;暗号化 $m$を送信したいメッセージとする．&#xA;$r$を乱数で生成し，$U=rG=(u_x,u_y)$を計算． 公開鍵$Y$を用いて，&#xA;$V = xU =(v_x,v_y)$&#xA;$c=v_x\oplus m$&#xA;を計算．$\oplus$は排他的論理和． $(U,c)$を暗号文として，送信． 復号化 以下のように復号する．&#xA;$V=xU=(v_x,v_y)$,&#xA;$m=v_x\oplus c$ プログラム # Random number r = 3 # Secret Key key = 3 # Base point g = [2,2] # Digits l = 5 # y^2 = x^3 + ax +b a = 0 b = 1 def Mod(x,y): if x &amp;lt; 0: x = x+y return x%y def invMod(x,y): count = 1 while True: tmp = x*count if tmp%y == 1: return count count += 1 def Ellipse(p,r): for _ in range(r): s = Mod(Mod((3*p[0]*p[0]+a),l)*invMod((2*p[1]),l),l) x = Mod(s*s-p[0]-p[0],l) y = Mod(s*(p[0]-x)-p[1],l) return [x,y] def encrypt(G,Y, m): U =Ellipse(G,r) V =Ellipse(Y,r) # XOR c = V[1] ^ m return U,c def decrypt(U, c, key): V = Ellipse(U,key) m = V[1] ^ c return m def main(): # Public Key Y = g Y = Ellipse(Y, key) print(&amp;#34;公開鍵：&amp;#34;,[a,b], g,Y) # Pingwen message = 4 print(&amp;#34;平文：&amp;#34;, message) # Encryption U,c = encrypt(g, Y, message) print(&amp;#34;暗号文：&amp;#34;,U,c) # Decryption decrypt_message = decrypt(U, c, key) print(&amp;#34;復号化メッセージ&amp;#34;, decrypt_message) if __name__ == &amp;#34;__main__&amp;#34;: main() </description>
    </item>
    <item>
      <title>バイナリ法によるべき乗計算のPythonプログラム</title>
      <link>https://yuhi-sa.github.io/posts/20201220_binary/1/</link>
      <pubDate>Sun, 20 Dec 2020 15:17:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20201220_binary/1/</guid>
      <description>バイナリ法 $x=a^k$のとき、$k$回の2乗計算が必要になるが、効率よく計算するためには、$a^{2^i}$を順次求めることで、計算量を$log(k)$回に抑えることができる。これがバイナリ法である。RSA暗号の複合時のべき乗計算などで用いられる。&#xA;具体例 $5^{21}$を計算する場合、以下のように展開する。&#xA;$5^{21}=5^{2^4}*5^{2^2}*5^{2^0}$&#xA;2進数に展開し、左から順に展開することにより計算を実行する。つまり、$21$の2進数表記である$10101$を使って以下のように計算する。&#xA;$5^{21} = 5^{(10101)_2} = 5^{(12^4 + 02^3 + 12^2 + 02^1 + 1*2^0)_2} = 5^{16} * 5^{4} * 5^{1}$&#xA;これにより、計算回数が大幅に削減される。&#xA;プログラム 以下は、Pythonでバイナリ法を用いたべき乗計算を行うプログラムである。&#xA;def binary_exponentiation(k: int, g: int, p: int) -&amp;gt; int: # 2進数表記に変換 k_binary = [] while k != 0: k_binary.append(k % 2) k = k // 2 if k == 1: k_binary.append(k) k = 0 # バイナリ法によるべき乗計算 y = 1 for i in reversed(range(len(k_binary))): if k_binary[i] == 1: y = (y * y % p) * g % p else: y = (y * y % p) return y このプログラムでは、入力としてべき乗の指数$k$、底$g$、法$p$を受け取り、バイナリ法を用いてべき乗計算を行い、計算結果を返す。</description>
    </item>
    <item>
      <title>ユークリッドの互除法と拡張ユークリッドの互除法のpythonプログラム</title>
      <link>https://yuhi-sa.github.io/posts/20201015_euclidean/1/</link>
      <pubDate>Thu, 15 Oct 2020 15:17:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20201015_euclidean/1/</guid>
      <description>ユークリッドの互除法とは ユークリッドの互除法とは、2つの整数 $a$ と $b$ $(a&amp;gt;b)$ が与えられたとき、$a$ を $b$ で割った余り $r$ とすることで、$a$ と $b$ の最大公約数を求める方法。除法の原理を利用し、割り算を繰り返すことによって最大公約数を求める。&#xA;ユークリッドの互除法のアルゴリズム 入力：整数$a,b$&#xA;出力：最大公約数 $d$&#xA;$a_0 = a$, $a_1 = b$ $a_i=0$のとき，&#xA;$d=a_{i-1}$とし終了 $a_{i-1}=a_iq_i+a_{i+1}$&#xA;として2に戻る プログラム def euclid(a,b): a_list = [] if a &amp;lt; b: a_list.append(b) a_list.append(a) if a &amp;gt;= b: a_list.append(a) a_list.append(b) i = 0 while(a_list[-1]!=0): a_list.append(a_list[i]%a_list[i+1]) i +=1 return a_list[-2] 拡張ユークリッドの互除法とは 拡張ユークリッドの互除法とは、一次不定方程式 $ax+by=d$ の一つの解を求める方法。$a_0=a$、$a_1=b$ とおくと、以下のように求めることができる。&#xA;$[\begin{array}{cc} a_{i-1} \ a_i \end{array}]= [\begin{array}{cc} a_iq_i+a_{i+1} \ a_i \end{array}]$ とすると， $[\begin{array}{cc} a_{i-1} \ a_i \end{array}]= [\begin{array}{cc} q_i &amp;amp; 1 \ 1 &amp;amp; 0 \end{array}] [\begin{array}{cc} a_i \ a_{i+1} \end{array}] $ とかける． $[\begin{array}{cc} q_i &amp;amp; 1 \ 1 &amp;amp; 0 \end{array}]$ の逆行列を，$L_i$とする． $[\begin{array}{cc} a_i \ a_{i+1} \end{array}]=L_i [\begin{array}{cc} a_{i-1} \ a_i \end{array}] $ これを繰り返すと， $[\begin{array}{cc} d \ 0 \end{array}]=L_i,\dots,L_2 [\begin{array}{cc} a \ b \end{array}] $ となる．</description>
    </item>
    <item>
      <title>代表的なフィルタ</title>
      <link>https://yuhi-sa.github.io/posts/20200901_filter/1/</link>
      <pubDate>Tue, 01 Sep 2020 15:17:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20200901_filter/1/</guid>
      <description>フィルタ(Filter) フィルタとは，測定された時系列データから信号成分だけを通し，ノイズ成分を除去する仕組みである．&#xA;モデル フィルタリングでは，時間ステップ$t$，初期値$x_0$，観測値$z_t$，制御入力$u_{t-1}$が与えられたときの，潜在状態$x_t$を推定する．推定値$x$はプロセスモデル$f$によって，観測値$z$は観測モデル$h$によって与えられる．&#xA;$$ x_t = f(x_{t-1},u_{t-1},q_{t-1}) \tag{1} $$ $$ z_t=h(x_t,r_t) \tag{2} $$ ここで，$q$は，プロセスノイズ，$r$は観測ノイズである．&#xA;$$ q\sim N(0,Q) $$ $$ r\sim N(0,R) $$&#xA;カルマンフィルタ(Kalman Filter) 目的 時刻$t$が観測されたとき，その状態を観測データ$z(t)$と時系列の状態空間モデルを用いて推定する．&#xA;方法 状態空間モデルの係数は既知であり，時間によらず一定であると仮定する(LTI:Linear Time-Invariant,線形時不変)．&#xA;Step1において，対象とする時系列をガウスノイズにより駆動された線形システムの出力とみなし，その線形システムの状態空間モデルを構築する．&#xA;Step2においてStep1で得られた状態空間モデルの状態$x(t)$を時系列データ$y(t)$から推定する． $x$は，xの平均$\mu$と共分散$\Sigma$によって表される．また，プロセスノイズを$Q$，観測ノイズを$R$とする．&#xA;$$ x \sim&#x9;(\mu,\Sigma) $$&#xA;Step1 予測ステップ&#xA;事前状態推定値&#xA;$$ \hat{\mu}=A\mu_{t-1}+B\mu_t \tag{3} $$&#xA;事前誤差共分散行列&#xA;$$ \hat{\Sigma}=A\Sigma_{t-1}A^T+Q_{t-1} \tag{4} $$&#xA;Step2 状態推定&#xA;カルマンゲイン&#xA;$$ K_t=\hat{\Sigma_t}H^T(\hat{\Sigma_tH^T+R_t})^{-1} \tag{5} $$ 状態推定値&#xA;$$ \mu_t=\hat{\mu_t}+K_t(z_t-H\hat{\mu_t}) \tag{6} $$ 事後誤差共分散行列&#xA;$$ \Sigma_t = (I_n-K_tH)\hat{\Sigma_t} \tag{7} $$&#xA;拡張カルマンフィルタ(Extended Kalman Filter) 目的 カルマンフィルターを非線形システムに拡張する．</description>
    </item>
    <item>
      <title>強化学習の全体像まとめ</title>
      <link>https://yuhi-sa.github.io/posts/20200831_rl_map/1/</link>
      <pubDate>Mon, 31 Aug 2020 15:17:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20200831_rl_map/1/</guid>
      <description>強化学習の全体像 プランニング問題 環境が既知の場合の逐次的意思決定問題&#xA;価値反復法&#xA;ベルマン最適作用素を繰り返し用いて最適価値関数を求める． $$ (B_{\star}v)(s)=\max_a{\pi(a|s)(g(s,a)+\gamma \sum p_T(s&amp;rsquo;|s,a)v(s&amp;rsquo;)} $$ $$ V^{\star}=\lim_{k\rightarrow \infty}(B_{*}^kV)(s) $$&#xA;方策反復法&#xA;ベルマン期待作用素を繰り返し用いて最適方策を求める． $$ (B_{\pi}v)(s)=\sum_a\pi(a|s)(g(s,a)+\gamma \sum p_T(s&amp;rsquo;|s,a)v(s&amp;rsquo;)) $$ $$ V^{\pi}=\lim_{k\rightarrow \infty}(B_{\pi}^kV)(s) $$ $$ \pi(s)=\arg\max_a{g(s,a)+\gamma \sum_{s&amp;rsquo;}p_T(s&amp;rsquo;|s,a)V^\pi(s&amp;rsquo;)} $$&#xA;強化学習 環境が既知の場合の逐次的意思決定問題&#xA;報酬や次状態を観測することでデータを収集して，データから方策を学習する．&#xA;価値関数Vの推定 方策$\pi$を固定して価値関数の推定を行う．&#xA;オフライン&#xA;ベルマン作用素を直接求められないので，まず標本近似によって近似ベルマン作用素を求める．そして，近似ベルマン作用素を価値関数用いて更新する． $$ \hat{V}(s)=\hat{B}(\hat{V},h_T^\pi)(s) $$&#xA;オンライン TD法&#xA;TD誤差$\delta$を計算して価値関数を更新する． $$ \delta=r_t+\gamma \hat{V}(s_{t+1})-\hat{V}(s_t) $$&#xA;$$ \hat{V}(s_t)=\hat{V}(s_t)+\alpha_t\delta $$&#xA;TD($\lambda$)法&#xA;エリジビリティートレースを用いて1エピソード分の価値を一括更新する． 行動価値関数Qの推定 方策$\pi$を固定して行動価値関数の推定を行う．&#xA;Q学習法&#xA;価値ベース：maxを取っているため推定行動価値関数が方策に依存しない． $$ \delta_t=r_t+\gamma \max_{a&amp;rsquo;}\hat{Q}(s_{t+1},a&amp;rsquo;)-\hat{Q}(s_t,a_t)&#xA;$$&#xA;$$ \hat{Q}(s_t,a_t)=\hat{Q}(s_t,a_t)+\alpha_t\delta_t $$&#xA;SARSA&#xA;方策ベース $$ \delta_t=r_t+\gamma \hat{Q}(s_{t+1},a&amp;rsquo;)-\hat{Q}(s_t,a_t) $$&#xA;$$ \hat{Q}(s_t,a_t)=\hat{Q}(s_t,a_t)+\alpha_t\delta_t $$</description>
    </item>
    <item>
      <title>[ROS]PublisherとSubscriberを1つのノードに書く方法</title>
      <link>https://yuhi-sa.github.io/posts/20200816_ros_pubsub/1/</link>
      <pubDate>Sun, 16 Aug 2020 15:17:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20200816_ros_pubsub/1/</guid>
      <description>ROS(Robot Operating System) ロボット・アプリケーション作成を支援するライブラリとツールを提供しているミドルウェアです．&#xA;これによりロボット同士の通信が簡易にできるようになります．&#xA;Pub &amp;amp; Sub通信 ROSでは，ROSのネットワークにつながった実行可能なものを&amp;quot;ノード&amp;quot;とよび，ノード間で&amp;quot;トピック&amp;quot;とよばれるメッセージをやり取りします．&#xA;メッセージを配信するノードをPublisher(配信者)，メッセージを受信するノードをSubscriber(購読者)と呼びます．&#xA;実行環境 ROS kinetic Ubuntu 16.04 LTS Python 3.8.5 Publisherのプログラム import rospy from std_msgs.msg import String def talker(): # Publisher(&amp;#39;Topic Name&amp;#39;, Type, Size) pub = rospy.Publisher(&amp;#39;chatter&amp;#39;, String, queue_size=10) # Init Nonde rospy.init_node(&amp;#39;talker&amp;#39;, anonymous=True) # Roop Period rate = rospy.Rate(10) # 10hz while not rospy.is_shutdown(): hello_str = &amp;#34;hello world %s&amp;#34; % rospy.get_time() rospy.loginfo(hello_str) # Publish Data pub.publish(hello_str) rate.sleep() if __name__ == &amp;#39;__main__&amp;#39;: try: talker() except rospy.</description>
    </item>
    <item>
      <title>About</title>
      <link>https://yuhi-sa.github.io/posts/about/</link>
      <pubDate>Sun, 16 Aug 2020 15:17:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/about/</guid>
      <description>勉強したことなどをメモしています．&#xA;間違いあれば教えていただければ幸いです．&#xA;連絡先 Google Form：forms.gle その他 いいなって思った言葉メモ 2024年目標 読む予定の本 </description>
    </item>
    <item>
      <title>いいなって思った言葉</title>
      <link>https://yuhi-sa.github.io/posts/quotations/</link>
      <pubDate>Sun, 16 Aug 2020 15:17:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/quotations/</guid>
      <description>いいなって思った言葉メモ 休憩するというのは、何もしないことではなく、いつもと違うことをすること。&#xA;努力しない者が使う妥協という言葉は、つまりは怠惰のことである。(Daigo)&#xA;人生とは思い出を作る作業&#xA;恋の女神は純愛よりも早い者勝ちを愛している。(かぐや様は告らせたい)&#xA;恋の本質は恐怖である。相手への畏れが失われた時、恋は色を失う。(かぐや様は告らせたい)&#xA;学校は、学ぶことを教育と定義し直すことによって、学校の外で学んだ人に無教育のレッテルを貼ることになるのだ(イヴァン・イリイチ)&#xA;真の発見の旅とは、新しい景色を探すことではない。新しい目で見ることなのだ。(マルスル・ブルースト)&#xA;人と会う時は神回しばり マコなり社長&#xA;シンプルな世の中の法則に従う方がいい マコなり社長&#xA;クーラーにずっと当たっていると感謝を忘れる(フェルミ研究所)&#xA;愛ほど歪んだ呪いはないよ(呪術廻戦 五条悟)&#xA;まだ大丈夫の次はもう遅い(Daigo)&#xA;皮肉も肉かあ(タイムマシーン3号)&#xA;結局、自身なんてものは楽をしていては身につかないのだ。(フェルミ研究所 りん)&#xA;失ったのではなく返したのだ。(エピクテトス)&#xA;相手の話がつまらないのではなく、あなたの聞き方がつまらないのだ。(マコなり社長)&#xA;人間なんてだいたい病気なんだから、それとうまく付き合うしかないよね。(よふかしのうた、ミドリ)&#xA;人の想いは言葉に換た時に、その殆どは失われる。(かぐや様は告らせたい)&#xA;気づきは思考の余白から生まれる(マコなり社長)&#xA;好きな人に何かを求めるのは、お母さんの代わりが欲しいだけ (大津さん)&#xA;愛とは環世界を拡げていく能力である。(白鳥春彦)&#xA;何かを成そうとする時、「無限に努力すること」を前提としてはいけない。努力は限りある資源だと捉えなければやり方を見誤る。だからまずは他人の知恵を借りるのが最も効率的な方法だと私は思う。(トニカクカワイイ　かぐや)&#xA;あざとさは想像力なんだよ(あざとくてなにが悪いの？)&#xA;辛いことを我慢して幸せになれるほど人生は甘くないよ(フェルミ研究所)&#xA;時には妥協する事も大事だよ。でも諦めなかった世界の君は、今の君よりほんの少し輝いているかもしれないね(ささみキッチン 部長)&#xA;人は油断するとつい他人を変えようとしてしまいます。敵を作りたくなります。被害者ヅラをしたくなります。その方が楽だから。そんな弱い自分と勇気を出して戦い続けること。それが幸せに生きることだと信じています。(マコなり社長)&#xA;コンフォートゾーンになったらやめどき&#xA;雨が降っても自分のせい(松下幸之助)&#xA;間違いだとしても疑ったりはしない。正しさとは自分を強く信じることだ。(ヒグチアイ)&#xA;心と体に余裕がある時に周りと競えばいい(中山講師)&#xA;怖いなと思いながら行動するのだ。行動しないから怖いのだ。&#xA;コミュニケーション能力は違う人とその違いを埋めていける能力&#xA;不機嫌で人を動かす赤子、ご機嫌で人を動かす大人&#xA;無知は罪だけれど、馬鹿は罪じゃないものね。馬鹿は罪じゃなくて、罰だもの。(化物語 戦場ヶ原ひたぎ)&#xA;やった方がいいことはやることになっている方がいい(中原淳)&#xA;たとえ結末に辿りつかなくても栞があればまた日常が始まる。熱中している物語から顔を上げ、生きるべき大切な日常が、、、物語に熱中するのも悪くないとは思うがら大切なのは日々の営みだ。休み休みでいいんだ。それでも人は幸せになれる。(トニカクカワイイ つかさ)&#xA;総理大臣ですら代わりが効くから大丈夫(とったび・あかり)&#xA;期待は感情の借金(夢をかなえるゾウ・ガネーシャ)&#xA;だから，まず運がいいって思うんや．自分にとってうれしゅうないことが起きても，まず嘘でもええから『運が良い』て思うんや．口に出して言うくらいの勢いがあってもええで，そしたら脳みそが勝手に運がええこと探しはじめる．自分に起きた出来事から何かを学ぼうと考え出すんや．そうやって自然の法則を学んでいくんや．(夢をかなえるゾウ・ガネーシャ)&#xA;あなたがいつか出会う苦難は，あなたが疎かにした今の報いだ(Daigo)&#xA;一番インターナショナルなものはドメスティックなもの(山田五郎)&#xA;井の中の蛙大海を知らず，されど空の深さを知る&#xA;力強いとは、相手を倒すことではない。怒って当然というときに自制できる力を持っていること(ムハンマド「ハディース」)&#xA;悪人とはゲームができるが、善人とはゲームはできない(中野好夫)&#xA;不幸を悔やむと、さらなる不幸が来る(出口治明)&#xA;「偶然」を大切にする人を運がいいと呼ぶ(出口治明)&#xA;本って自分が選んで買っているって思う人が圧倒的に多いんですが，実は本が読者を選んでるんですよ(中村信仁)&#xA;本はご飯、ネットはおやつ(岡田斗司夫)&#xA;自分の機嫌は自分で取る(みやぞん)&#xA;人々の共感を得るのは，いつの時代も体験ではなく妄想なんだから(冴えカノ・町田)&#xA;わからない面白さがあるということは、それだけあなたがつまらない人間だということ(ハヤテのごとく・鷺ノ宮いすみ)&#xA;挨拶は存在承認、感謝は行動承認(マコなり社長)&#xA;行くかどうかはわからなくても旅の準備は欠かすな(ハヤテのごとく・西沢歩)&#xA;人生って優しくなるためにあるんだと思います．昨日のわたしよりも，今日のわたしがちょっとだけやさしい人間であればいいなと思いながら生きています．(青ブタ・牧之原翔子)&#xA;明日から頑張るんじゃない今日だけ頑張るんだ今日をがんばった者…今日をがんばり始めた者にのみ…明日が来るんだよ(カイジ・班長大槻)&#xA;重ならないはずだった人生が重なるから面白いのだ！！(ハヤテのごとく・三千院ナギ)&#xA;どんだけ素敵な場所に来ようと、つまらない顔をしてたら人生ごとつまらなくなるぞ(ハヤテのごとく・三千院ナギ)&#xA;亡き女を想うとかいて妄想と読む(ハヤテのごとく)&#xA;三文は約90円．90円くらいで早起きしてられるか！(トニカクカワイイ)&#xA;ねだるな勝ち取れ(フェルミ研究所)</description>
    </item>
    <item>
      <title>プライバシーポリシー</title>
      <link>https://yuhi-sa.github.io/posts/privacy_policy/</link>
      <pubDate>Sun, 16 Aug 2020 15:17:23 +0900</pubDate>
      <guid>https://yuhi-sa.github.io/posts/privacy_policy/</guid>
      <description>広告の配信について 当サイトは第三者配信の広告サービス「Google Adsense グーグルアドセンス」を利用しています． 広告配信事業者は，ユーザーの興味に応じた広告を表示するためにCookie（クッキー）を使用することがあります．&#xA;Cookie（クッキー）を無効にする設定およびGoogleアドセンスに関する詳細は「広告 – ポリシーと規約 – Google」をご覧ください．&#xA;また，当サイトは，Amazon.co.jpを宣伝しリンクすることによってサイトが紹介料を獲得できる手段を提供することを目的に設定されたアフィリエイトプログラムである，Amazonアソシエイト・プログラムの参加者です．&#xA;第三者がコンテンツおよび宣伝を提供し，訪問者から直接情報を収集し，訪問者のブラウザにCookie（クッキー）を設定したりこれを認識したりする場合があります．&#xA;アクセス解析ツールについて 当サイトでは，Googleによるアクセス解析ツール「Googleアナリティクス」を利用しています．&#xA;このGoogleアナリティクスはトラフィックデータの収集のためにCookieを使用しています．このトラフィックデータは匿名で収集されており，個人を特定するものではありません.この機能はCookieを無効にすることで収集を拒否することが出来ますので，お使いのブラウザの設定をご確認ください．この規約に関して，詳しくはここをクリックしてください．&#xA;免責事項 当サイトで掲載している画像の著作権・肖像権等は各権利所者に帰属致します．権利を侵害する目的ではございません．記事の内容や掲載画像等に問題がございましたら，各権利所有者様本人が直接メールでご連絡下さい．確認後，対応させて頂きます．&#xA;当サイトからリンクやバナーなどによって他のサイトに移動された場合，移動先サイトで提供される情報，サービス等について一切の責任を負いません．&#xA;当サイトのコンテンツ・情報につきまして，可能な限り正確な情報を掲載するよう努めておりますが，誤情報が入り込んだり，情報が古くなっていることもございます．&#xA;当サイトに掲載された内容によって生じた損害等の一切の責任を負いかねますのでご了承ください．</description>
    </item>
    <item>
      <title>DS201の実施_Compaction</title>
      <link>https://yuhi-sa.github.io/posts/20230516_dse_cassandra/17/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20230516_dse_cassandra/17/</guid>
      <description>DS201: Foundations of Apache Cassandra™ and DataStax Enterpriseの学習&#xA;概要 Compactionは、不要なデータを削除し、データの配置を最適化することで、データベースのパフォーマンスを向上させる。Compactionには、メジャーとマイナーコンパクションの2つの主要なタイプがある。&#xA;マイナーコンパクション マイナーコンパクションは、SSTable内のデータのみを対象とし、データの重複を削除し、1つのSSTableにまとめることで容量を削減する。マイナーコンパクションでは、トゥームストーン（削除マーカー）が処理され、不要なデータが完全に削除される。トゥームストーンは、Cassandraで削除操作が行われた場合に挿入されるマーカーである。データの削除は即座に行われず、トゥームストーンが挿入されてデータが「削除済み」とマークされる。Compactionプロセスでは、トゥームストーンのあるSSTableから削除マーカーを削除し、不要なデータを完全にクリーンアップする。&#xA;メジャーコンパクション メジャーコンパクションは、複数のSSTable間のマージを行う。複数のSSTableを1つの新しいSSTableに結合し、データの重複を削除し、不要なトゥームストーンを削除する。また、GC（ガベージコレクション）も実行する。GCは、Compactionプロセスが完了した後に、不要なデータとトゥームストーンを物理的に削除する役割を果たす。これにより、ディスクスペースが解放され、データベースのパフォーマンスが向上する。&#xA;メジャーコンパクションは、データベースの大規模な再構築を必要とするため、システムの負荷が高くなる。したがって、Cassandraでは通常、バックグラウンドで自動的にメジャーコンパクションがスケジュールされる。メジャーコンパクションのスケジュールは、ディスクの使用状況やデータの更新頻度などを考慮して、自動的に調整される。</description>
    </item>
    <item>
      <title>GithubのプロフィールREADMEをデコる，動くprofile summaryを自作してみた</title>
      <link>https://yuhi-sa.github.io/posts/20210631_github_cards/1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://yuhi-sa.github.io/posts/20210631_github_cards/1/</guid>
      <description>はじめに GithubのREADMEに，自身のGitHubのリポジトリのコミット数や使用言語をグラフィカルに表示するSummary Cardsがある．自分は以下のものを使っていた．&#xA;GitHub Profile Summary Cards しかし，唐突に動きのあるものが欲しいと思ってつくってみた．&#xA;リポジトリ情報の取得 GitHubのAPIよりリポジトリの情報を取得することができる．&#xA;https://api.github.com/users/+ username + /repos 上記のAPIから以下のようなjson形式の情報を取得することができる．&#xA;[ { &amp;#34;id&amp;#34;: 312465317, &amp;#34;node_id&amp;#34;: &amp;#34;MDEwOlJlcG9zaXRvcnkzMTI0NjUzMTc=&amp;#34;, &amp;#34;name&amp;#34;: &amp;#34;1day&amp;#34;, &amp;#34;full_name&amp;#34;: &amp;#34;yuhi-sa/1day&amp;#34;, &amp;#34;private&amp;#34;: false, &amp;#34;owner&amp;#34;: { &amp;#34;login&amp;#34;: &amp;#34;yuhi-sa&amp;#34;, &amp;#34;id&amp;#34;: 62089243, &amp;#34;node_id&amp;#34;: &amp;#34;MDQ6VXNlcjYyMDg5MjQz&amp;#34;, &amp;#34;avatar_url&amp;#34;: &amp;#34;https://avatars.githubusercontent.com/u/62089243?v=4&amp;#34;, &amp;#34;gravatar_id&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;url&amp;#34;: &amp;#34;https://api.github.com/users/yuhi-sa&amp;#34;, &amp;#34;html_url&amp;#34;: &amp;#34;https://github.com/yuhi-sa&amp;#34;, &amp;#34;followers_url&amp;#34;: &amp;#34;https://api.github.com/users/yuhi-sa/followers&amp;#34;, &amp;#34;following_url&amp;#34;: &amp;#34;https://api.github.com/users/yuhi-sa/following{/other_user}&amp;#34;, &amp;#34;gists_url&amp;#34;: &amp;#34;https://api.github.com/users/yuhi-sa/gists{/gist_id}&amp;#34;, &amp;#34;starred_url&amp;#34;: &amp;#34;https://api.github.com/users/yuhi-sa/starred{/owner}{/repo}&amp;#34;, &amp;#34;subscriptions_url&amp;#34;: &amp;#34;https://api.github.com/users/yuhi-sa/subscriptions&amp;#34;, &amp;#34;organizations_url&amp;#34;: &amp;#34;https://api.github.com/users/yuhi-sa/orgs&amp;#34;, &amp;#34;repos_url&amp;#34;: &amp;#34;https://api.github.com/users/yuhi-sa/repos&amp;#34;, &amp;#34;events_url&amp;#34;: &amp;#34;https://api.github.com/users/yuhi-sa/events{/privacy}&amp;#34;, &amp;#34;received_events_url&amp;#34;: &amp;#34;https://api.github.com/users/yuhi-sa/received_events&amp;#34;, &amp;#34;type&amp;#34;: &amp;#34;User&amp;#34;, &amp;#34;site_admin&amp;#34;: false }, ...リポジトリ数分続く ] ここから，リポジトリごとの言語とサイズを取得する．&#xA;こちらにGitHubで利用可能なAPIが記載されている． Cardの作成 pythonのmatplotlib.</description>
    </item>
  </channel>
</rss>
