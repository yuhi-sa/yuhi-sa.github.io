<!DOCTYPE html>
<html lang="ja" dir="ltr">
<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<title>変分オートエンコーダ(VAE) | tomato blog</title>
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet"
  integrity="sha384-9ndCyUaIbzAi2FUVXJi0CjmCapSmO7SnpJef0486qhLnuZ2cdeRhO02iuK6FUUVM" crossorigin="anonymous">
    <link rel="stylesheet" href="/css/main.min.f0006a9d6f3625f7765522eece9b7cccee5b1dc15a581742039a67489209bcb4.css" integrity="sha256-8ABqnW82Jfd2VSLuzpt8zO5bHcFaWBdCA5pnSJIJvLQ=" crossorigin="anonymous">
    <link rel="stylesheet" href="/css/syntax.min.aa0332253f313dc48905008b4ab314155e5a13302588d25bcf4949f7c1abdde0.css" integrity="sha256-qgMyJT8xPcSJBQCLSrMUFV5aEzAliNJbz0lJ98Gr3eA=" crossorigin="anonymous">


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css">


<script src="https://code.jquery.com/jquery-3.2.1.slim.min.js"></script>


<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js"></script>


<script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js"></script>


<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>


<script>
  MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']]
    }
  };
</script>


</head>
<body>
  <header>
    <h1>tomato blog</h1>

    <nav class="navbar navbar-expand-lg navbar-light bg-light">
      <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
      </button>
      <div class="collapse navbar-collapse" id="navbarNav">
        <ul class="navbar-nav ml-auto">
      <li class="nav-item">
        <a ZgotmplZ href="https://yuhi-sa.github.io/" class="navbar-brand" > Blog </a>
      </li>
      <li class="nav-item">
        <a ZgotmplZ href="https://yuhi-sa.github.io/tags" class="navbar-brand" > Tags </a>
      </li>
      <li class="nav-item">
        <a ZgotmplZ href="https://yuhi-sa.github.io/posts/about" class="navbar-brand" > About </a>
      </li>
      <li class="nav-item">
        <a ZgotmplZ href="https://yuhi-sa.github.io/posts/privacy_policy" class="navbar-brand" > privacy policy </a>
      </li>
        </ul>
      </div>
    </nav>
  

  </header>
  <main>
    
  <h1>変分オートエンコーダ(VAE)</h1>

  
  
  <time datetime="2021-03-18T12:00:23&#43;09:00">2021年3月18日</time>

  <p>EMアルゴリズムでは，完全データの分布$p(z|x,\theta)$と不完全データの分布$p(z|x,\hat{\theta})$の関数系は同じであった．
VAEでは，2つの分布の関数系が異なってもよいという一般化を行う．
そのため以下の表記では，</p>
<ul>
<li>$p(z|x,\hat{\theta})$を認識モデル(エンコーダ)$q_\Phi(z|x)$</li>
<li>$p(z|x,\theta)$を生成モデル(デコーダ)$p_\theta(x|z)$</li>
</ul>
<p>とする．
また，潜在変数$z$は観測値$x$の持つ情報を別の形で表現しているため符号(コード)とよぶ．</p>
<h1 id="オートエンコーダ自己符号化器">オートエンコーダ(自己符号化器)</h1>
<p>オートエンコーダは，入力と出力が一致するようにパラメータの学習を行う装置である．VAEは変分下界を使って訓練を行うオートエンコーダである．</p>
<p>入力と同じ内容を出力する装置では中間的な層において符号化が行われており，これは情報圧縮をしていることに相当する．</p>
<h1 id="vaeにおける変分下界">VAEにおける変分下界</h1>
<p>EMアルゴリズムで使用した変分下界を$\theta$と$\phi$を用いて書き直す．
<img src=".././VAE%E5%A4%89%E5%88%86%E4%B8%8B%E7%95%8C.png" alt=""></p>
<!-- raw HTML omitted -->
<p>EMアルゴリズムによる混合ガウスモデルの学習では$z$はone-hotベクトルとしたが，VAEでは連続値である．よって$z$は多変量正規分布に従うモデルを用いる．</p>
<h2 id="認識モデル">認識モデル</h2>
<p>VAEでは認識モデル$q_\Phi(z|x)$として以下のように定義される多変量正規分布を用いる．</p>
<p>$$q_\Phi(z|x)=\Pi_{j=1}^k\mathcal{N}(z_j|\mu_j(x),\sigma^2(x))$$</p>
<p>$\mu_j,\sigma_j^2$としてニューラルネットワークを使用するのが一般的である．</p>
<h2 id="生成モデル">生成モデル</h2>
<p>生成モデル$p_\theta(x|z)$としてどのような確率分布が使われるかは$x$がどのような変数であるかに依存する．$x$がone-hot表現であればマルチヌーイ分布が使える．$x$が連続値ベクトルの場合，以下のように分散を1とする多変量正規分布が使える．</p>
<p>$$p_\theta(x|z)=\Pi_{h=1}^m \mathcal{N}(x_h|\nu_h(z),1)$$</p>
<h2 id="符号の事前分布">符号の事前分布</h2>
<p>標準正規分布の積を使用することが多い．</p>
<p>$$p_\theta(z)=\Pi_{j=1}^k\mathcal{N}(z_j|0,1)$$</p>
<h1 id="勾配降下法">勾配降下法</h1>
<p>VAEの学習は変分下界が増加していくように，パラメータ$\theta$と$\phi$を変えていくことで行われる．
具体的には$\mathcal{B}(\theta,\phi)$の$\theta$と$\phi$での微分，すなわち勾配を求め，勾配方向にパラメータを少しづつ変える．</p>
<p>事前分布を上記のように定義した場合は，事前分布に$\theta$を使わないため，$\mathcal{D}(q_\phi(z|x)||p_\theta(z))$は$\theta$を含まない．そのため$\theta$による勾配は不要である．$\phi$による勾配は合成関数の微分を使うと以下のように展開される．</p>
<p>$$\nabla_\phi \mathcal{D}(q_\phi(z|x)||p_\theta(z))=\sum_{j=1}^k
(\frac{d\mathcal{D}(q_\theta(z|x)||p_\theta(z))}{d\mu_j}\nabla_\theta \mu_j
+
\frac{d\mathcal{D}(q_\theta(z|x)||p_\theta(z))}{d\sigma_j^2}\nabla_\theta \sigma_j^2)$$</p>
<h1 id="参考">参考</h1>
<ul>
<li>手塚 太郎，&quot;<a href="https://amzn.to/3cCILQM">しくみがわかるベイズ統計と機械学習</a>&quot;</li>
</ul>
  
  <div>
    <div>Tags:</div>
    <ul>
        <li><a href="/tags/%E3%81%97%E3%81%8F%E3%81%BF%E3%81%8C%E3%82%8F%E3%81%8B%E3%82%8B%E3%83%99%E3%82%A4%E3%82%BA%E7%B5%B1%E8%A8%88%E3%81%A8%E6%A9%9F%E6%A2%B0%E5%AD%A6%E7%BF%92/">しくみがわかるベイズ統計と機械学習</a></li>
    </ul>
  </div>


  </main>
  <footer>
    <p>Copyright 2023. All rights reserved.</p>

  </footer>
</body>
</html>
