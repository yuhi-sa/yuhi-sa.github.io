<!doctype html><html lang=en dir=ltr data-theme=light><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=theme-color content="#e74c3c"><meta name=format-detection content="telephone=no"><meta name=robots content="index,follow"><meta name=description content="A comprehensive guide to JavaScript async processing covering the event loop mechanism, callback hell, Promise chaining, and async/await syntax with code …"><meta name=author content="yuhi-sa"><link rel=canonical href=https://yuhi-sa.github.io/en/posts/20221229_async_await/1/><meta property="og:type" content="article"><meta property="og:title" content="JavaScript Asynchronous Processing: From Callbacks to Promise and Async/Await"><meta property="og:description" content="A comprehensive guide to JavaScript async processing covering the event loop mechanism, callback hell, Promise chaining, and async/await syntax with code …"><meta property="og:url" content="https://yuhi-sa.github.io/en/posts/20221229_async_await/1/"><meta property="og:site_name" content="tomato blog"><meta property="og:locale" content="en"><meta property="og:image" content="https://yuhi-sa.github.io/ogp.jpeg"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><meta property="article:published_time" content="2022-12-29T09:00:23+09:00"><meta property="article:modified_time" content="2026-02-14T00:31:41+09:00"><meta property="article:tag" content="JavaScript"><meta property="article:tag" content="Asynchronous Processing"><meta property="article:section" content="posts"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="JavaScript Asynchronous Processing: From Callbacks to Promise and Async/Await"><meta name=twitter:description content="A comprehensive guide to JavaScript async processing covering the event loop mechanism, callback hell, Promise chaining, and async/await syntax with code …"><meta name=twitter:image content="https://yuhi-sa.github.io/ogp.jpeg"><title>JavaScript Asynchronous Processing: From Callbacks to Promise and Async/Await | tomato blog</title><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=preconnect href=https://cdn.jsdelivr.net crossorigin><link rel=preconnect href=https://pagead2.googlesyndication.com crossorigin><link rel=dns-prefetch href=https://pagead2.googlesyndication.com><link rel=icon href=https://yuhi-sa.github.io/favicon.ico><link rel=alternate hreflang=ja href=https://yuhi-sa.github.io/posts/20221229_async_await/1/><link rel=alternate hreflang=en href=https://yuhi-sa.github.io/en/posts/20221229_async_await/1/><link rel=alternate hreflang=x-default href=https://yuhi-sa.github.io/en/posts/20221229_async_await/1/><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"JavaScript Asynchronous Processing: From Callbacks to Promise and Async\/Await","description":"A comprehensive guide to JavaScript async processing covering the event loop mechanism, callback hell, Promise chaining, and async\/await syntax with code examples.","author":{"@type":"Person","name":"yuhi-sa","url":"https:\/\/yuhi-sa.github.io\/"},"publisher":{"@type":"Organization","name":"tomato blog","logo":{"@type":"ImageObject","url":"https:\/\/yuhi-sa.github.io\/ogp.jpeg"},"url":"https:\/\/yuhi-sa.github.io\/"},"datePublished":"2022-12-29T09:00:23\u002b09:00","dateModified":"2026-02-14T00:31:41\u002b09:00","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/yuhi-sa.github.io\/en\/posts\/20221229_async_await\/1\/"},"url":"https:\/\/yuhi-sa.github.io\/en\/posts\/20221229_async_await\/1\/","wordCount":1073,"keywords":["JavaScript","Asynchronous Processing"],"articleSection":"Posts","inLanguage":"en","timeRequired":"PT6M"}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"tomato blog","item":"https:\/\/yuhi-sa.github.io\/en\/"},{"@type":"ListItem","position":2,"name":"Posts","item":"https:\/\/yuhi-sa.github.io\/en\/posts\/"},{"@type":"ListItem","position":3,"name":"JavaScript Asynchronous Processing: From Callbacks to Promise and Async\/Await"}]}</script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel=stylesheet><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css integrity="sha512-iecdLmaskl7CVkqkXNQ/ZH/XLlvWZOJyj7Yy7tcenmpD1ypASozpmT/E0iPtmFIB46ZmdtAc9eNBvH0H/ZpiBw==" crossorigin=anonymous referrerpolicy=no-referrer><link href=https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css rel=stylesheet integrity=sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH crossorigin=anonymous><link rel=stylesheet href=/css/variables.min.72a177faa7b12de55dcc39c4ab6b6392116718d5e2735dab0214511354ecb973.css integrity="sha256-cqF3+qexLeVdzDnEq2tjkhFnGNXic12rAhRRE1TsuXM=" crossorigin=anonymous><link rel=stylesheet href=/css/main.min.f96a20189e31f38ad6d3afd6435427cd8819cd0ba84dc5c0e46b70e6f5a52583.css integrity="sha256-+WogGJ4x84rW06/WQ1QnzYgZzQuoTcXA5Gtw5vWlJYM=" crossorigin=anonymous><link rel=stylesheet href=/css/syntax.min.e379066489e20d5433ca35ac1f468fd9e8859705a62d77a79bb7379ac3613848.css integrity="sha256-43kGZIniDVQzyjWsH0aP2eiFlwWmLXenm7c3msNhOEg=" crossorigin=anonymous><style>body{font-family:-apple-system,BlinkMacSystemFont,inter,segoe ui,Roboto,sans-serif;line-height:1.5;color:#000;background:#fff}[data-theme=dark] body{color:#fff;background:#000}.container{max-width:768px;margin:0 auto;padding:0 1rem}</style><script src=https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js integrity=sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz crossorigin=anonymous defer></script><script src=/js/dark-mode.min.3e457dc8346f064bee795e6f9b73e1516dcd059e750c521fe4b445f9ea9a7821.js integrity="sha256-PkV9yDRvBkvueV5vm3PhUW3NBZ51DFIf5LRF+eqaeCE=" defer></script><script>window.addEventListener("load",function(){const e=document.createElement("script");e.async=!0,e.src="https://www.googletagmanager.com/gtag/js?id=G-LN6QP6VVM3",document.head.appendChild(e),e.onload=function(){window.dataLayer=window.dataLayer||[];function e(){dataLayer.push(arguments)}e("js",new Date),e("config","G-LN6QP6VVM3")}})</script></head><body itemscope itemtype=https://schema.org/WebPage class=theme-tomatohugo><a href=#main-content class="skip-link sr-only sr-only-focusable" aria-label="Skip to main content">Skip to main content</a><header role=banner class=site-header><nav class="navbar navbar-expand-lg navbar-light bg-light" role=navigation aria-label="Main navigation"><div class=container><a class=navbar-brand href=https://yuhi-sa.github.io/ aria-label="Return to tomato blog homepage">tomato blog
</a><button class="navbar-toggler d-lg-none" type=button data-bs-toggle=collapse data-bs-target=#navbarNav aria-controls=navbarNav aria-expanded=false aria-label="Toggle navigation menu">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarNav><ul class="navbar-nav ms-auto" role=menubar><li class=nav-item role=none><a class=nav-link href=https://yuhi-sa.github.io/en/ role=menuitem aria-label="Navigate to Blog">Blog</a></li><li class=nav-item role=none><a class=nav-link href=https://yuhi-sa.github.io/en/tags/ role=menuitem aria-label="Navigate to Tags">Tags</a></li><li class=nav-item role=none><a class=nav-link href=https://yuhi-sa.github.io/en/posts/about/ role=menuitem aria-label="Navigate to About">About</a></li><li class=nav-item role=none><a class=nav-link href=https://yuhi-sa.github.io/en/posts/privacy_policy/ role=menuitem aria-label="Navigate to Privacy policy">Privacy policy</a></li><li class=nav-item role=none><button id=darkModeToggle class="nav-link btn btn-link border-0" type=button role=menuitem aria-label="Toggle dark mode" title="Switch between light and dark themes">
<i class="fas fa-moon" id=darkModeIcon aria-hidden=true></i>
<span class="d-lg-none ms-2">ダークモード</span></button></li></ul></div></div></nav><script data-ad-client=ca-pub-9558545098866170 async crossorigin=anonymous src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></header><main id=main-content role=main class=site-main aria-label="Main content"><div class="container mt-4"><div class="row justify-content-center"><div class=col-lg-8><article itemscope itemtype=https://schema.org/Article><header class=article-header><h1 itemprop=headline>JavaScript Asynchronous Processing: From Callbacks to Promise and Async/Await</h1><p class="lead article-description" itemprop=description>A comprehensive guide to JavaScript async processing covering the event loop mechanism, callback hell, Promise chaining, and async/await syntax with code examples.</p><div class=article-meta><time datetime=2022-12-29T09:00:23+09:00 itemprop=datePublished><i class="far fa-calendar-alt me-1" aria-hidden=true></i>
December 29, 2022
</time><time datetime=2026-02-14T00:31:41+09:00 itemprop=dateModified class=ms-3><i class="far fa-edit me-1" aria-hidden=true></i>
Updated
February 14, 2026
</time><span aria-label="Reading time" class=ms-3><i class="far fa-clock me-1" aria-hidden=true></i>
6 min read</span></div><div class=article-tags role=group aria-label="Article tags"><a href=/en/tags/javascript/ class="badge badge-custom text-decoration-none me-1" rel=tag itemprop=keywords>JavaScript
</a><a href=/en/tags/asynchronous-processing/ class="badge badge-custom text-decoration-none me-1" rel=tag itemprop=keywords>Asynchronous Processing</a></div></header><div class=article-content itemprop=articleBody><h2 id=why-asynchronous-processing-matters-in-javascript>Why Asynchronous Processing Matters in JavaScript</h2><h3 id=single-threaded>Single-Threaded</h3><p>JavaScript fundamentally operates as <strong>single-threaded</strong>. This means it can only execute one task at a time. In web browser environments, the JavaScript execution thread shares the same thread as the browser&rsquo;s UI rendering processes such as page layout, repaint (reflow), and garbage collection.</p><p>Therefore, if a time-consuming JavaScript process occupies the thread, page responsiveness degrades and the user interface appears frozen. <strong>Asynchronous processing</strong> is essential to solve this problem.</p><h3 id=how-asynchronous-processing-works>How Asynchronous Processing Works</h3><p>Asynchronous processing separates time-consuming tasks (e.g., network requests, timers) from the main thread and allows the next operation to proceed without waiting for those tasks to complete. This prevents UI freezing and creates the appearance of parallel execution.</p><h4 id=event-loop>Event Loop</h4><p>JavaScript&rsquo;s asynchronous processing is achieved through a mechanism called the <strong>event loop</strong>. The JavaScript engine (such as V8) works with the following main components.</p><ul><li><strong>JavaScript Engine</strong>:<ul><li><strong>Heap</strong>: A memory area where objects and variables are stored.</li><li><strong>Call Stack</strong>: A LIFO (Last In, First Out) area that manages currently executing function calls. Functions are pushed onto the stack when called and removed when execution completes.</li></ul></li><li><strong>Web APIs (Browser Environment)</strong>:<ul><li>API groups provided by the browser (DOM manipulation, Ajax requests, timer functions like <code>setTimeout</code>, etc.). These operate on threads separate from the JavaScript engine.</li></ul></li><li><strong>Event Queue / Task Queue</strong>:<ul><li>A FIFO (First In, First Out) queue where callback functions received from Web APIs are stored.</li></ul></li></ul><p>The event loop coordinates asynchronous processing as follows.</p><ol><li>JavaScript code executes and function calls are pushed onto the call stack.</li><li>When asynchronous functions like <code>setTimeout</code> or <code>fetch</code> are called, the task is passed to Web APIs and processing begins in the Web API execution environment.</li><li>When processing in a Web API completes, the result (or callback function) is placed in the event queue.</li><li>The event loop constantly monitors whether the <strong>call stack is empty</strong> (no tasks currently executing on the main thread).</li><li>When the call stack becomes empty, the event loop takes the first callback function from the event queue, pushes it onto the call stack, and executes it.</li></ol><h3 id=callback-hell>Callback Hell</h3><p>In early JavaScript async processing, <strong>callback functions</strong> were heavily used to wait for processing completion before executing the next task. However, when multiple async operations are chained, callback functions become deeply nested, severely degrading code readability and maintainability. This is called &ldquo;callback hell.&rdquo;</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// Callback hell example
</span></span></span><span class=line><span class=cl><span class=nx>setTimeout</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nx>setTimeout</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nx>setTimeout</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=mi>3</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>},</span> <span class=mi>300</span><span class=p>);</span> <span class=c1>// Execute after 300ms
</span></span></span><span class=line><span class=cl>  <span class=p>},</span> <span class=mi>200</span><span class=p>);</span> <span class=c1>// Execute after 200ms
</span></span></span><span class=line><span class=cl><span class=p>},</span> <span class=mi>100</span><span class=p>);</span> <span class=c1>// Execute after 100ms
</span></span></span></code></pre></div><p>To solve this problem, <code>Promise</code> was introduced in ES2015.</p><h2 id=promise-object-es2015>Promise Object [ES2015]</h2><p><code>Promise</code> is an object introduced in ES2015 (ECMAScript 2015) that represents the <strong>eventual completion (or failure)</strong> of an asynchronous operation and its resulting value. It wraps the state of an asynchronous operation and provides a mechanism to call registered callbacks when that state changes.</p><h3 id=basic-usage-of-promise>Basic Usage of Promise</h3><p>The <code>Promise</code> constructor takes a function with two arguments: <code>resolve</code> and <code>reject</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// asyncPromiseTask function returns a Promise instance
</span></span></span><span class=line><span class=cl><span class=kd>function</span> <span class=nx>asyncPromiseTask</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=k>new</span> <span class=nb>Promise</span><span class=p>((</span><span class=nx>resolve</span><span class=p>,</span> <span class=nx>reject</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Write asynchronous processing here
</span></span></span><span class=line><span class=cl>    <span class=c1>// Call resolve() on success
</span></span></span><span class=line><span class=cl>    <span class=c1>// Call reject(error object) on failure
</span></span></span><span class=line><span class=cl>    <span class=kr>const</span> <span class=nx>success</span> <span class=o>=</span> <span class=nb>Math</span><span class=p>.</span><span class=nx>random</span><span class=p>()</span> <span class=o>&gt;</span> <span class=mf>0.5</span><span class=p>;</span> <span class=c1>// Example: 50% chance of success
</span></span></span><span class=line><span class=cl>    <span class=nx>setTimeout</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=nx>success</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>resolve</span><span class=p>(</span><span class=s2>&#34;Success!&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>reject</span><span class=p>(</span><span class=k>new</span> <span class=nb>Error</span><span class=p>(</span><span class=s2>&#34;Failed...&#34;</span><span class=p>));</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>},</span> <span class=mi>1000</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>});</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Register callbacks using then() for when the Promise resolves or rejects
</span></span></span><span class=line><span class=cl><span class=nx>asyncPromiseTask</span><span class=p>()</span>
</span></span><span class=line><span class=cl>  <span class=p>.</span><span class=nx>then</span><span class=p>((</span><span class=nx>result</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;Success handler:&#34;</span><span class=p>,</span> <span class=nx>result</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>})</span>
</span></span><span class=line><span class=cl>  <span class=p>.</span><span class=k>catch</span><span class=p>((</span><span class=nx>error</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Register failure handler with catch() (recommended)
</span></span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>error</span><span class=p>(</span><span class=s2>&#34;Failure handler:&#34;</span><span class=p>,</span> <span class=nx>error</span><span class=p>.</span><span class=nx>message</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>})</span>
</span></span><span class=line><span class=cl>  <span class=p>.</span><span class=k>finally</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Register handler that runs regardless of success/failure
</span></span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;Processing complete.&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>});</span>
</span></span></code></pre></div><h3 id=promise-states>Promise States</h3><p>A <code>Promise</code> instance internally has one of the following three states.</p><ul><li><strong>Pending</strong>: The initial state where the asynchronous operation has not yet completed.</li><li><strong>Fulfilled</strong>: The state where the asynchronous operation succeeded and a result value is available. Enters this state when <code>resolve()</code> is called.</li><li><strong>Rejected</strong>: The state where the asynchronous operation failed and an error occurred. Enters this state when <code>reject()</code> is called.</li></ul><p>Once a <code>Promise</code> becomes <code>Fulfilled</code> or <code>Rejected</code>, it will not change to another state.</p><h3 id=promise-chaining>Promise Chaining</h3><p>When you want to execute multiple asynchronous operations sequentially, use <strong>Promise chaining</strong>. Since <code>then()</code> always returns a new <code>Promise</code> instance, you can chain additional <code>then()</code> and <code>catch()</code> methods on its return value. This eliminates callback hell and improves code readability.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=nb>Promise</span><span class=p>.</span><span class=nx>resolve</span><span class=p>()</span>
</span></span><span class=line><span class=cl>  <span class=p>.</span><span class=nx>then</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;Step 1&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>asyncPromiseTask</span><span class=p>();</span> <span class=c1>// Return a Promise
</span></span></span><span class=line><span class=cl>  <span class=p>})</span>
</span></span><span class=line><span class=cl>  <span class=p>.</span><span class=nx>then</span><span class=p>((</span><span class=nx>result</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;Step 2:&#34;</span><span class=p>,</span> <span class=nx>result</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=s2>&#34;Next data&#34;</span><span class=p>;</span> <span class=c1>// Return a value (automatically wrapped with Promise.resolve)
</span></span></span><span class=line><span class=cl>  <span class=p>})</span>
</span></span><span class=line><span class=cl>  <span class=p>.</span><span class=nx>then</span><span class=p>((</span><span class=nx>data</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;Step 3:&#34;</span><span class=p>,</span> <span class=nx>data</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>})</span>
</span></span><span class=line><span class=cl>  <span class=p>.</span><span class=k>catch</span><span class=p>((</span><span class=nx>error</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>error</span><span class=p>(</span><span class=s2>&#34;An error occurred:&#34;</span><span class=p>,</span> <span class=nx>error</span><span class=p>.</span><span class=nx>message</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>});</span>
</span></span></code></pre></div><h3 id=limitations-of-promise>Limitations of Promise</h3><p>While <code>Promise</code> solved callback hell, some challenges remained.</p><ul><li>Coordination between async operations becomes a chain of <code>then()</code> methods, still a special coding style compared to synchronous code.</li><li>Error handling uses the <code>catch()</code> method rather than the <code>try...catch</code> syntax, which can be less intuitive.</li><li><code>Promise</code> is just an object without language-level syntax support, leading to demand for more natural async code writing.</li></ul><h2 id=asyncawait-es2017>Async/Await [ES2017]</h2><p><code>async/await</code> is JavaScript syntax based on <code>Promise</code> that allows asynchronous processing to be written more like synchronous code.</p><h3 id=async-functions><code>async</code> Functions</h3><p>Adding the <code>async</code> keyword before a function declares it as an asynchronous function. <code>async</code> functions always return a <code>Promise</code> instance.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kr>async</span> <span class=kd>function</span> <span class=nx>doAsync</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=s2>&#34;value&#34;</span><span class=p>;</span> <span class=c1>// This value is wrapped as Promise.resolve(&#34;value&#34;)
</span></span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// The above is roughly equivalent to:
</span></span></span><span class=line><span class=cl><span class=kd>function</span> <span class=nx>doAsyncLegacy</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nb>Promise</span><span class=p>.</span><span class=nx>resolve</span><span class=p>(</span><span class=s2>&#34;value&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=await-expression><code>await</code> Expression</h3><p>The <code>await</code> keyword, usable only within <code>async</code> functions, waits for a <code>Promise</code> to resolve (<code>Fulfilled</code> or <code>Rejected</code>). Using <code>await</code> allows you to wait for async processing to complete before executing the next line of code, enabling a more intuitive, readable synchronous-style writing of the flow that was previously achieved with <code>Promise</code> chaining.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kr>async</span> <span class=kd>function</span> <span class=nx>asyncMain</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;Processing started&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=c1>// Wait until the Promise resolves
</span></span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>result</span> <span class=o>=</span> <span class=kr>await</span> <span class=nx>asyncPromiseTask</span><span class=p>();</span> <span class=c1>// asyncPromiseTask returns a Promise
</span></span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;Promise resolved:&#34;</span><span class=p>,</span> <span class=nx>result</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;Processing finished&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>asyncMain</span><span class=p>();</span>
</span></span></code></pre></div><h3 id=error-handling>Error Handling</h3><p>The <code>await</code> expression <code>throw</code>s an error when a <code>Promise</code> is <code>Rejected</code>. This allows async processing errors to be caught using the standard <code>try...catch</code> syntax, just like synchronous processing, making error handling very simple.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kr>async</span> <span class=kd>function</span> <span class=nx>asyncMainWithErrorHandling</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>try</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;Starting potentially error-prone processing&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kr>const</span> <span class=nx>value</span> <span class=o>=</span> <span class=kr>await</span> <span class=nx>asyncPromiseTask</span><span class=p>();</span> <span class=c1>// Promise that may fail
</span></span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;Success:&#34;</span><span class=p>,</span> <span class=nx>value</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>catch</span> <span class=p>(</span><span class=nx>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>error</span><span class=p>(</span><span class=s2>&#34;Error caught:&#34;</span><span class=p>,</span> <span class=nx>error</span><span class=p>.</span><span class=nx>message</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>finally</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;Finally block executed.&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>asyncMainWithErrorHandling</span><span class=p>();</span>
</span></span></code></pre></div><p><code>async/await</code> dramatically improved JavaScript&rsquo;s asynchronous processing, enabling even complex async logic to be written concisely.</p></div><div class="ad-slot in-content my-3"><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-9558545098866170></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><footer class=article-footer></footer><meta itemprop=wordCount content="1073"><meta itemprop=url content="https://yuhi-sa.github.io/en/posts/20221229_async_await/1/"></article><nav class="post-nav mt-5" aria-label="Post navigation"><a href=/en/posts/20221111_react/1/ class="post-nav__item post-nav__item--prev"><span class="post-nav__label text-muted"><i class="fas fa-arrow-left me-1" aria-hidden=true></i>前の記事
</span><span class=post-nav__title>Building a React/TypeScript Development Environment with Webpack and Babel</span>
</a><a href=/en/posts/20221230_vim/1/ class="post-nav__item post-nav__item--next"><span class="post-nav__label text-muted">次の記事<i class="fas fa-arrow-right ms-1" aria-hidden=true></i>
</span><span class=post-nav__title>Essential Vim Operations and Recommended Plugins</span></a></nav><section class="related-posts mt-5" aria-label="Related posts"><h2 class=related-posts__title>関連記事</h2><div class=related-posts__grid><article class=related-posts__item><h3 class=related-posts__item-title><a href=/en/posts/20221111_react/1/>Building a React/TypeScript Development Environment with Webpack and Babel</a></h3><div class=card-meta><time datetime=2022-11-11>November 11, 2022</time></div></article></div></section><nav class="article-navigation mt-4" aria-label="Article navigation"><a href=/en/posts/ class="btn btn-outline-secondary btn-sm mb-3"><i class="fas fa-arrow-left me-1" aria-hidden=true></i>
Back to posts</a><nav aria-label="Breadcrumb navigation" class=breadcrumb-nav role=navigation><ol class=breadcrumb itemscope itemtype=https://schema.org/BreadcrumbList><li class=breadcrumb-item itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a href=/en/ itemprop=item aria-label="Navigate to homepage"><i class="fas fa-home" aria-hidden=true></i>
<span itemprop=name>tomato blog</span>
</a><meta itemprop=position content="1"></li><li class=breadcrumb-item itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a href=https://yuhi-sa.github.io/en/ itemprop=item aria-label="Navigate to tomato blog"><span itemprop=name>tomato blog</span>
</a><meta itemprop=position content="2"></li><li class=breadcrumb-item itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a href=https://yuhi-sa.github.io/en/posts/ itemprop=item aria-label="Navigate to Posts"><span itemprop=name>Posts</span>
</a><meta itemprop=position content="3"></li><li class="breadcrumb-item active" aria-current=page itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><span itemprop=name>JavaScript Asynchronous Processing: From Callbacks to Promise and Async/Await</span>
<meta itemprop=position content="4"></li></ol></nav></nav></div></div></div></main><footer role=contentinfo class=site-footer><div class="container pt-4 pb-3" style="border-top:2px solid var(--accent,#e54d2e)"><div class="row justify-content-center"><div class="col-md-8 text-center"><p class="copyright-text text-muted mb-2">&copy; 2026 yuhi-sa. All rights reserved.</p><p class="theme-attribution text-muted small mt-2 mb-0">Powered by
<a href=https://gohugo.io/ target=_blank rel=noopener class=text-decoration-none>Hugo</a>
with
<a href=https://github.com/yuhi-sa/tomatohugo target=_blank rel=noopener class=text-decoration-none>TomatoHugo</a></p></div></div></div></footer><script src=https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js integrity=sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz crossorigin=anonymous defer></script><script src=/js/dark-mode.min.3e457dc8346f064bee795e6f9b73e1516dcd059e750c521fe4b445f9ea9a7821.js integrity="sha256-PkV9yDRvBkvueV5vm3PhUW3NBZ51DFIf5LRF+eqaeCE=" defer></script><script>window.addEventListener("load",function(){const e=document.createElement("script");e.async=!0,e.src="https://www.googletagmanager.com/gtag/js?id=G-LN6QP6VVM3",document.head.appendChild(e),e.onload=function(){window.dataLayer=window.dataLayer||[];function e(){dataLayer.push(arguments)}e("js",new Date),e("config","G-LN6QP6VVM3")}})</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"WebPage","name":"JavaScript Asynchronous Processing: From Callbacks to Promise and Async\/Await","url":"https:\/\/yuhi-sa.github.io\/en\/posts\/20221229_async_await\/1\/","description":"A comprehensive guide to JavaScript async processing covering the event loop mechanism, callback hell, Promise chaining, and async\/await syntax with code examples.","inLanguage":"en","isPartOf":{"@type":"WebSite","name":"tomato blog","url":"https:\/\/yuhi-sa.github.io\/"}}</script></body></html>